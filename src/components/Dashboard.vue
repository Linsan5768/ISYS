<template>
  <!-- Âä†ËΩΩÊåáÁ§∫Âô®ÂíåÈîôËØØ‰ø°ÊÅØ -->
  <div v-if="isLoading" class="loading-indicator">
    Loading data...
  </div>
  
  <div v-if="error" class="error-message">
    {{ error }}
    <button @click="useTestData" class="btn-test-data">Use Test Data</button>
  </div>
  
  <div v-if="isTestMode" class="test-mode-badge">
    Test Mode - Displaying Sample Data
  </div>

  <!-- ‰∏ªÈù¢Êùø -->
  <div class="dashboard-container">
    <div class="main-card">
      <div class="back-arrow" @click="goBack">
        <span class="arrow-icon">‚Üê</span>
        <span class="back-text">Back</span>
      </div>

      <h2 class="dashboard-title">Tax Dashboard</h2>
      
      <!-- ÁªÑ‰ª∂Ë°å -->
      <div class="components-row">
        <!-- Tax Liabilities (ÂéüTax Tasks) -->
        <div class="inner-card tasks-section">
          <h3>Current Tax Liabilities</h3>
          <div class="info-tooltip">
            <span class="help-icon">?</span>
            <div class="tooltip-content">
              <p><strong>Red items</strong>: Taxes to be paid</p>
              <p>This section shows your current tax obligations</p>
            </div>
          </div>
          <div class="scrollable-content">
            <div class="liabilities-list">
              <div v-for="liability in currentTaxLiabilities.slice(0, 5)" :key="liability.id" class="liability-item">
                <div class="liability-info">
                  <span class="liability-name">{{ liability.name }}</span>
                  <span class="liability-amount" :style="{ color: '#d32f2f' }">
                    {{ formatCurrency(liability.amount) }}
                  </span>
                </div>
                <div class="liability-due-date">
                  Due: {{ formatDate(liability.dueDate) }}
                </div>
                <div class="liability-status" :class="liability.status">
                  {{ liability.statusText }}
                </div>
              </div>
              <!-- ÊòæÁ§∫Ë∞ÉËØï‰ø°ÊÅØÔºåÂ∏ÆÂä©ËØäÊñ≠Êï∞ÊçÆÈóÆÈ¢ò -->
              <div v-if="currentTaxLiabilities.length === 0 && taxLiabilities.length > 0" class="debug-info">
                <p>There are {{ taxLiabilities.length }} tax liability records, but none meet the current display criteria.</p>
                <button @click="refreshTaxLiabilities" class="btn-refresh">Refresh Data</button>
              </div>
              <div v-if="taxLiabilities.length === 0" class="no-data">
                No current tax liabilities
              </div>
            </div>
          </div>
          <div class="fixed-summary" v-if="currentTaxLiabilities.length > 0">
            <div class="summary-item">
              <div class="summary-inner">
                <span class="summary-label">Total Tax Obligations:</span>
                <span class="summary-amount" :style="{ color: '#d32f2f' }">
                  {{ formatCurrency(totalTaxObligations) }}
                </span>
              </div>
            </div>
          </div>
        </div>

        <!-- Payment History (ÂéüRecent Income) -->
        <div class="inner-card income-table">
          <h3>Financial Transactions History</h3>
          <div class="info-tooltip">
            <span class="help-icon">?</span>
            <div class="tooltip-content">
              <p><strong>Income</strong>: Salary, business income, and investment gains</p>
              <p><strong>Tax Refund/Reimbursement</strong>: Tax returns and expense reimbursements</p>
              <p><strong>Deductible Expenses</strong>: Expenses deductible from taxes</p>
              <p><strong>Investment</strong>: Investment capital outflows</p>
            </div>
          </div>
          <div class="scrollable-content">
            <table>
              <thead>
                <tr>
                  <th>Date</th>
                  <th>Type</th>
                  <th>Description</th>
                  <th>Amount</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="payment in paymentHistory.slice(0, 5)" :key="payment.id">
                  <td>{{ formatDate(payment.date) }}</td>
                  <td class="transaction-type" :class="payment.type">{{ payment.transactionType }}</td>
                  <td>{{ payment.description }}</td>
                  <td class="amount" :class="payment.type === 'credit' ? 'positive' : 'negative'" 
                      :style="{ color: payment.type === 'credit' ? '#2e7d32' : '#d32f2f' }">
                    {{ formatCurrency(payment.amount) }}
                  </td>
                </tr>
                <tr v-if="paymentHistory.length === 0">
                  <td colspan="4" class="no-data">No transaction history</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="fixed-summary" v-if="paymentHistory.length > 0">
            <div class="summary-row">
              <div class="summary-label">Net Income/Expense:</div>
              <div class="amount" :class="netTransactionAmount >= 0 ? 'positive' : 'negative'"
                  :style="{ color: netTransactionAmount >= 0 ? '#2e7d32' : '#d32f2f' }">
                {{ formatCurrency(netTransactionAmount) }}
              </div>
            </div>
          </div>
        </div>

        <!-- Outstanding Credits/Debits -->
        <div class="inner-card expense-table">
          <h3>Financial Items & Tax Estimates</h3>
          <div class="info-tooltip">
            <span class="help-icon">?</span>
            <div class="tooltip-content">
              <p><strong>Credit (Green)</strong>: Available tax refunds, reimbursements, and deductible items</p>
              <p><strong>Debit (Red)</strong>: Estimated taxes due and other financial obligations</p>
              <p>This section shows outstanding financial items and system-estimated tax items</p>
            </div>
          </div>
          <div class="scrollable-content">
            <table>
              <thead>
                <tr>
                  <th>Type</th>
                  <th>Description</th>
                  <th>Amount</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="item in outstandingItems.slice(0, 5)" :key="item.id || item.description">
                  <td class="transaction-type" :class="item.type.toLowerCase()">{{ item.type }}</td>
                  <td>{{ item.description }}</td>
                  <td class="amount" :class="item.type === 'Credit' ? 'positive' : 'negative'"
                      :style="{ color: item.type === 'Credit' ? '#2e7d32' : '#d32f2f' }">
                    {{ formatCurrency(item.amount) }}
                  </td>
                </tr>
                <tr v-if="outstandingItems.length === 0">
                  <td colspan="3" class="no-data">No outstanding items</td>
                </tr>
              </tbody>
            </table>
          </div>
          <div class="fixed-summary" v-if="outstandingItems.length > 0">
            <div class="summary-row">
              <div class="summary-label">Net Financial Position:</div>
              <div class="amount" :class="netOutstandingAmount >= 0 ? 'positive' : 'negative'"
                  :style="{ color: netOutstandingAmount >= 0 ? '#2e7d32' : '#d32f2f' }">
                {{ formatCurrency(netOutstandingAmount) }}
              </div>
            </div>
          </div>
        </div>

        <!-- Action Buttons ÂíåËßÜÂõæÂàáÊç¢ -->
        <div class="inner-card action-controls">
          <div class="action-buttons">
            <button class="btn-export" @click="showExportOptions = !showExportOptions">
              <span class="action-icon">üìä</span> EXPORT
            </button>
            <button class="btn-filter" @click="showFilterOptions = !showFilterOptions">
              <span class="action-icon">üîç</span> FILTER
            </button>
          </div>
          <div class="view-toggle">
            <button 
              class="view-btn" 
              :class="{ 'active': viewMode === 'yearly' }"
              @click="changeViewMode('yearly')"
            >
              Yearly
            </button>
            <button 
              class="view-btn" 
              :class="{ 'active': viewMode === 'quarterly' }"
              @click="changeViewMode('quarterly')"
            >
              Quarterly
            </button>
          </div>
        </div>
      </div>

      <!-- Filter Panel Overlay -->
      <div class="filter-overlay" v-if="showFilterOptions">
        <div class="filter-backdrop" @click="showFilterOptions = false"></div>
        <div class="filter-modal">
          <button class="close-button" @click="showFilterOptions = false">√ó</button>
          <h3>Filter Options</h3>
          
          <div class="filter-controls">
            <!-- Â¢ûÂä†ËßÜÂõæÊ®°ÂºèÈÄâÊã©Âô® -->
            <div class="filter-section">
              <div class="filter-label">View Mode</div>
              <div class="filter-toggle">
                <button 
                  class="toggle-btn" 
                  :class="{ 'active': filterViewMode === 'yearly' }"
                  @click="filterViewMode = 'yearly'"
                >
                  Yearly
                </button>
                <button 
                  class="toggle-btn" 
                  :class="{ 'active': filterViewMode === 'quarterly' }"
                  @click="filterViewMode = 'quarterly'"
                >
                  Quarterly
                </button>
              </div>
            </div>
            
            <!-- Yearly View Filters -->
            <div class="filter-section" v-if="filterViewMode === 'yearly'">
              <div class="filter-label">Year Range</div>
              <div class="filter-row">
                <div class="filter-group half-width">
                  <label for="start-year-filter">From Year</label>
                  <select id="start-year-filter" v-model="filterStartYear" class="select-control">
                    <option v-for="year in availableYears" :key="year" :value="year">{{ year }}</option>
                  </select>
                </div>
                
                <div class="filter-group half-width">
                  <label for="end-year-filter">To Year</label>
                  <select id="end-year-filter" v-model="filterEndYear" class="select-control">
                    <option v-for="year in availableYears" :key="year" :value="year">{{ year }}</option>
                  </select>
                </div>
              </div>
            </div>
            
            <!-- Quarterly View Filters -->
            <div class="filter-section" v-if="filterViewMode === 'quarterly'">
              <div class="filter-label">Quarter Selection</div>
              <div class="filter-row">
                <div class="filter-group half-width">
                  <label for="filter-year">Year</label>
                  <select id="filter-year" v-model="filterQuarterYear" class="select-control">
                    <option v-for="year in availableYears" :key="year" :value="year">{{ year }}</option>
                  </select>
                </div>
                
                <div class="filter-group half-width">
                  <label for="filter-quarter">Quarter</label>
                  <select id="filter-quarter" v-model="filterQuarter" class="select-control">
                    <option value="all">All</option>
                    <option value="1">Q1</option>
                    <option value="2">Q2</option>
                    <option value="3">Q3</option>
                    <option value="4">Q4</option>
                  </select>
                </div>
              </div>
            </div>
            
            <div class="filter-actions">
              <button class="btn-apply" @click="applyFilters">Apply</button>
              <button class="btn-reset" @click="resetFilters">Reset</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Export Panel Overlay -->
      <div class="filter-overlay" v-if="showExportOptions">
        <div class="filter-backdrop" @click="showExportOptions = false"></div>
        <div class="export-modal">
          <button class="close-button" @click="showExportOptions = false">√ó</button>
          <h3>Export Options</h3>
          
          <div class="export-controls">
            <div class="filter-section">
              <div class="filter-label">Export Format</div>
              <div class="export-format-toggle">
                <button 
                  class="toggle-btn" 
                  :class="{ 'active': exportFormat === 'csv' }"
                  @click="exportFormat = 'csv'"
                >
                  CSV
                </button>
                <button 
                  class="toggle-btn" 
                  :class="{ 'active': exportFormat === 'pdf' }"
                  @click="exportFormat = 'pdf'"
                >
                  PDF
                </button>
              </div>
            </div>
            
            <div class="filter-section">
              <div class="filter-label">Select Data to Export</div>
              <div class="export-options">
                <div class="export-option">
                  <input type="checkbox" id="export-liabilities" v-model="exportOptions.liabilities">
                  <label for="export-liabilities">Current Tax Liabilities</label>
                </div>
                <div class="export-option">
                  <input type="checkbox" id="export-transactions" v-model="exportOptions.transactions">
                  <label for="export-transactions">Financial Transactions History</label>
                </div>
                <div class="export-option">
                  <input type="checkbox" id="export-outstanding" v-model="exportOptions.outstanding">
                  <label for="export-outstanding">Financial Items & Tax Estimates</label>
                </div>
              </div>
            </div>
            
            <div class="export-actions">
              <button class="btn-cancel" @click="showExportOptions = false">Cancel</button>
              <button class="btn-export-now" @click="exportData">Export</button>
            </div>
          </div>
        </div>
      </div>

      <!-- ÂõæË°®Âå∫Âüü -->
      <div class="components-row charts-row">
        <!-- Income Trend -->
        <div class="inner-card income-chart-card">
          <h3>Income Analysis by {{ viewMode === 'yearly' ? 'Year' : 'Quarter' }}</h3>
          <div class="chart">
            <div v-if="!hasIncomeData" class="chart-placeholder">
              <div class="placeholder-text">Income data will be displayed here</div>
            </div>
            <canvas v-else class="chart-area" id="income-chart"></canvas>
          </div>
        </div>
        
        <!-- Expense Chart - Redesigned to show financial flow -->
        <div class="inner-card expense-chart-card">
          <h3>Financial Trends by {{ viewMode === 'yearly' ? 'Year' : 'Quarter' }}</h3>
          <div class="chart">
            <div v-if="!hasExpenseData" class="chart-placeholder">
              <div class="placeholder-text">Financial trend data will be displayed here</div>
            </div>
            <canvas v-else class="chart-area" id="expense-chart"></canvas>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import Chart from "chart.js/auto";
import axios from 'axios';

export default {
  name: 'UserDashboard',
  created() {
    // Ê≥®ÂÖ•toastÂíånotificationsÊúçÂä°
    this.toast = this.$root.$parent?.$options?.__compPromise?.data?.provides?.toast || null;
    this.notifications = this.$root.$parent?.$options?.__compPromise?.data?.provides?.notifications || null;
  },
  data() {
    return {
      toast: null,
      notifications: null,
      viewMode: 'yearly', // Can be 'yearly' or 'quarterly'
      hasIncomeData: false,
      hasExpenseData: false,
      incomeChart: null,
      expenseChart: null,
      tasks: [
        { description: 'MONTHLY DECLARATION', completed: false },
        { description: 'MID-YEAR DECLARATION', completed: false },
        { description: 'SALARY DECLARATION', completed: false }
      ],
      incomeData: [],
      expenseData: [],
      showFilterOptions: false,
      showExportOptions: false, // ÊéßÂà∂ÂØºÂá∫ÈÄâÈ°πÈù¢ÊùøÊòæÁ§∫
      availableYears: [],
      formData: [], // All tax form data from server
      isLoading: false,
      error: null,
      isTestMode: false, // ÊòØÂê¶‰ΩøÁî®ÊµãËØïÊï∞ÊçÆÁöÑÊ†áÂøó
      filterStartYear: new Date().getFullYear() - 4,
      filterEndYear: new Date().getFullYear(),
      filterViewMode: 'yearly', // Á≠õÈÄâÈù¢Êùø‰∏≠ÁöÑËßÜÂõæÊ®°Âºè
      filterQuarterYear: new Date().getFullYear(), // Â≠£Â∫¶ËßÜÂõæÁöÑÂπ¥‰ªΩ
      filterQuarter: 'all', // ÈÄâÊã©ÁöÑÂ≠£Â∫¶Ôºå'all'Ë°®Á§∫ÂÖ®ÈÉ®
      exportFormat: 'csv', // ÈªòËÆ§ÂØºÂá∫Ê†ºÂºè
      exportOptions: {
        liabilities: true,
        transactions: true,
        outstanding: true
      },
      maxYearsRange: 10, // ÊúÄÂ§ßÂèØÈÄâÂπ¥‰ªΩËåÉÂõ¥
      FORM_STATUS: {
        DRAFT: 'Saved as Draft',
        SUBMITTED: 'Submitted',
        FAILED: 'Submission Failed'
      },
      // Êî∂ÂÖ•Á±ªÂûãÂèäÂÖ∂Á®éÁéá
      INCOME_TYPES: {
        SALARY: { 
          label: 'Salary', 
          taxRate: 0.32, 
          thresholds: [
            { min: 0, max: 18200, rate: 0 },
            { min: 18200, max: 45000, rate: 0.19 },
            { min: 45000, max: 120000, rate: 0.325 },
            { min: 120000, max: 180000, rate: 0.37 },
            { min: 180000, max: Infinity, rate: 0.45 }
          ],
          color: 'rgba(75, 192, 192, 0.6)'
        },
        INVESTMENT: { 
          label: 'Investment', 
          taxRate: 0.15, 
          returnRate: 0.08, // 8% Âπ≥ÂùáÊäïËµÑÂõûÊä•Áéá
          color: 'rgba(153, 102, 255, 0.6)'
        },
        BUSINESS: { 
          label: 'Business', 
          taxRate: 0.25, 
          color: 'rgba(255, 159, 64, 0.6)'
        },
        OTHER: { 
          label: 'Other', 
          taxRate: 0.30, 
          color: 'rgba(201, 203, 207, 0.6)'
        }
      },
      // ‰ø°Áî®ÂíåÊâ£Èô§Á±ªÂûã
      CREDIT_TYPES: {
        REFUND: { 
          label: 'Tax Refund', 
          interestRate: 0.03, // 3% Âπ¥Âà©Áéá
          color: 'rgba(75, 192, 192, 0.6)'
        },
        REIMBURSEMENT: { 
          label: 'Reimbursement', 
          interestRate: 0, 
          color: 'rgba(54, 162, 235, 0.6)'
        }
      },
      DEDUCTION_TYPES: {
        BUSINESS_EXPENSE: { 
          label: 'Business Expense', 
          deductionRate: 1.0, // 100% ÂèØÊäµÊâ£
          color: 'rgba(255, 99, 132, 0.6)'
        },
        EDUCATION: { 
          label: 'Education', 
          deductionRate: 0.5, // 50% ÂèØÊäµÊâ£
          color: 'rgba(255, 159, 64, 0.6)'
        },
        CHARITY: { 
          label: 'Charity', 
          deductionRate: 1.0, // 100% ÂèØÊäµÊâ£
          color: 'rgba(255, 205, 86, 0.6)'
        },
        MEDICAL: { 
          label: 'Medical', 
          deductionRate: 0.8, // 80% ÂèØÊäµÊâ£
          color: 'rgba(153, 102, 255, 0.6)'
        }
      },
      taxLiabilities: [],
      paymentHistory: [],
      outstandingItems: []
    }
  },
  
  methods: {
    // Ê∑ªÂä†Êñ∞ÁöÑÊ†áÂáÜÂåñÊó•ÊúüÊ†ºÂºèÂáΩÊï∞
    standardizeDate(dateString) {
      if (!dateString) return null;
      
      // Â¶ÇÊûúÊòØÊó•ÊúüÂØπË±°ÔºåÁõ¥Êé•ËøîÂõû
      if (dateString instanceof Date) return dateString;
      
      // ÁßªÈô§ÊâÄÊúâÁ©∫Ê†ºÔºåÁ°Æ‰øùÊ†ºÂºèÊòØYYYY-MM-DD
      const cleanDateStr = String(dateString).replace(/\s+/g, '');
      
      // Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÊó•ÊúüÊ†ºÂºè
      if (/^\d{4}-\d{1,2}-\d{1,2}$/.test(cleanDateStr)) {
        const date = new Date(cleanDateStr);
        if (!isNaN(date.getTime())) {
          return date;
        }
      }
      
      console.warn(`Êó†Ê≥ïÊ†áÂáÜÂåñÊó•Êúü: "${dateString}"`);
      return null;
    },
    
    // Format date for display - ÊõøÊç¢ÂéüÊúâÁöÑformatDateÊñπÊ≥ï
    formatDate(dateString) {
      if (!dateString) return '-';
      
      // ‰ΩøÁî®Ê†áÂáÜÂåñÂáΩÊï∞Â§ÑÁêÜÊó•Êúü
      const date = this.standardizeDate(dateString);
      if (!date || isNaN(date.getTime())) return '-';
      
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
    },
    
    // Format currency for display
    formatCurrency(amount) {
      // Format as USD
      return new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: 'USD',
        minimumFractionDigits: 2,
        maximumFractionDigits: 2
      }).format(amount);
    },
    
    // Fetch all form data from the server
    async fetchFormData() {
      this.isLoading = true;
      this.error = null;
      this.isTestMode = false;
      
      console.log("Fetching form data...");
      
      // If running on GitHub Pages, use test data
      if (this.$isGitHubPages) {
        console.log("Running on GitHub Pages, using test data");
        setTimeout(() => {
          this.useTestData();
          this.isLoading = false;
        }, 500);
        return;
      }
      
      try {
        // Use setTimeout to simulate network delay and ensure the loading indicator is visible
        await new Promise(resolve => setTimeout(resolve, 500));
        
        const response = await axios.get('/api/get_tax_forms');
        console.log("Server response data:", response.data);
        
        if (response.data.success) {
          this.formData = response.data.forms || [];
          console.log(`Retrieved ${this.formData.length} form records`);
          
          // Ê£ÄÊü•Ë°®ÂçïÊï∞ÊçÆÁöÑÊ†ºÂºèÂíåÊó•ÊúüÂ≠óÊÆµ
          if (this.formData.length > 0) {
            console.log("Ë°®ÂçïÊó•ÊúüÂ≠óÊÆµÊ†∑Êú¨:", {
              firstItem: {
                id: this.formData[0].id,
                dateValue: this.formData[0].date,
                dateType: typeof this.formData[0].date,
                allFields: Object.keys(this.formData[0]).join(', ')
              }
            });
          }
          
          // Check if data is empty, use test data if so
          if (!this.formData || this.formData.length === 0) {
            console.log("Server returned empty data, using test data");
            this.useTestData();
          } else {
            this.processFormData();
          }
        } else {
          this.error = response.data.message || 'Failed to load form data';
          console.error("Failed to load form data:", this.error);
          // Try to load data from localStorage
          this.loadFromLocalStorage();
        }
      } catch (error) {
        console.error("Error fetching form data:", error);
        this.error = 'Cannot connect to server, trying local data';
        
        // Load from localStorage as a backup
        this.loadFromLocalStorage();
      } finally {
        this.isLoading = false;
      }
    },
    
    // Load form data from localStorage
    loadFromLocalStorage() {
      try {
        const savedFormsData = localStorage.getItem('taxForms');
        console.log("Attempting to load form data from localStorage");
        
        if (savedFormsData) {
          const localForms = JSON.parse(savedFormsData);
          console.log(`Loaded ${localForms.length} form records from localStorage`);
          this.formData = localForms;
          
          // Check if data is empty, use test data if so
          if (!this.formData || this.formData.length === 0) {
            console.log("localStorage data is empty, using test data");
            this.useTestData();
          } else {
            this.processFormData();
          }
        } else {
          console.log("No form data in localStorage, using test data");
          this.useTestData();
        }
      } catch (e) {
        console.error("Error loading local form data:", e);
        this.useTestData();
      }
    },
    
    // Use test data with new salary types and deduction types
    useTestData() {
      console.log("Using test data to display charts");
      this.isTestMode = true;
      
      // Clear test notification markers from localStorage
      try {
        const keys = Object.keys(localStorage);
        keys.forEach(key => {
          if (key.startsWith('sentLiabilityReminders_') || 
              key.startsWith('sentDashboardReminders_')) {
            localStorage.removeItem(key);
          }
        });
        console.log("Cleared test notification markers");
      } catch (e) {
        console.error("Error clearing test notification markers:", e);
      }
      
      // Get current year and month
      const currentYear = new Date().getFullYear();
      
      // Generate test data
      this.formData = [
        // Income data - add new salary items
        {
          id: "test-salary-1",
          date: `${currentYear}-05-05`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "Monthly Salary",
          price: 12000,
          status: "submitted"
        },
        {
          id: "test-salary-2",
          date: `${currentYear}-04-20`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "Fixed Salary",
          price: 1500,
          status: "submitted"
        },
        {
          id: "test-investment-1",
          date: `${currentYear}-03-10`,
          declarationType: "income",
          incomeType: "INVESTMENT",
          declarationName: "Stock Dividends",
          price: 5000,
          status: "submitted"
        },
        {
          id: "test-business-1",
          date: `${currentYear}-02-15`,
          declarationType: "income",
          incomeType: "BUSINESS",
          declarationName: "Business Income",
          price: 8500,
          status: "submitted"
        },
        
        // Add credit and refund items
        {
          id: "test-credit-1",
          date: `${currentYear}-03-15`,
          declarationType: "credit",
          creditType: "REFUND",
          declarationName: "Tax Refund",
          price: 3200,
          status: "submitted"
        },
        {
          id: "test-credit-2",
          date: `${currentYear}-04-10`,
          declarationType: "credit",
          creditType: "REIMBURSEMENT",
          declarationName: "Work Expense Reimbursement",
          price: 1200,
          status: "submitted"
        },
        
        // Add deduction items
        {
          id: "test-deduction-1",
          date: `${currentYear}-02-08`,
          declarationType: "deduction",
          deductionType: "BUSINESS_EXPENSE",
          declarationName: "Office Supplies",
          price: 2500,
          status: "submitted"
        },
        {
          id: "test-deduction-2",
          date: `${currentYear}-03-12`,
          declarationType: "deduction",
          deductionType: "EDUCATION",
          declarationName: "Professional Course",
          price: 1800,
          status: "submitted"
        },
        {
          id: "test-deduction-3",
          date: `${currentYear}-04-05`,
          declarationType: "deduction",
          deductionType: "CHARITY",
          declarationName: "Charity Donation",
          price: 1000,
          status: "submitted"
        },
        {
          id: "test-deduction-4",
          date: `${currentYear}-05-18`,
          declarationType: "deduction",
          deductionType: "MEDICAL",
          declarationName: "Medical Expenses",
          price: 2200,
          status: "submitted"
        },
        
        // Debt and tax items
        {
          id: "test-tax-1",
          date: `${currentYear}-03-20`,
          declarationType: "tax",
          taxType: "SALARY",
          declarationName: "Income Tax Payment",
          price: 3500,
          status: "submitted"
        },
        {
          id: "test-liability-1",
          date: `${currentYear}-04-15`,
          declarationType: "liability",
          declarationName: "Bank Loan Interest",
          price: 1200,
          status: "submitted"
        },
        
        // Add extra month data for annual view testing
        {
          id: "test-salary-month-1",
          date: `${currentYear}-01-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "January Salary",
          price: 10000,
          status: "submitted"
        },
        {
          id: "test-salary-month-2",
          date: `${currentYear}-02-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "February Salary",
          price: 10000,
          status: "submitted"
        },
        {
          id: "test-investment-month-1",
          date: `${currentYear}-02-20`,
          declarationType: "income",
          incomeType: "INVESTMENT",
          declarationName: "Quarterly Investment Return",
          price: 3500,
          status: "submitted"
        },
        
        // Add data from previous years for annual view
        {
          id: "test-salary-y1",
          date: `${currentYear-1}-05-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "Last Year Salary",
          price: 120000,
          status: "submitted"
        },
        {
          id: "test-investment-y1",
          date: `${currentYear-1}-06-10`,
          declarationType: "income",
          incomeType: "INVESTMENT",
          declarationName: "Last Year Investment",
          price: 25000,
          status: "submitted"
        },
        {
          id: "test-deduction-y1",
          date: `${currentYear-1}-07-20`,
          declarationType: "deduction",
          deductionType: "BUSINESS_EXPENSE",
          declarationName: "Last Year Business Expense",
          price: 15000,
          status: "submitted"
        },
        {
          id: "test-salary-y2",
          date: `${currentYear-2}-05-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "2 Years Ago Salary",
          price: 110000,
          status: "submitted"
        },
        {
          id: "test-business-y2",
          date: `${currentYear-2}-08-10`,
          declarationType: "income",
          incomeType: "BUSINESS",
          declarationName: "2 Years Ago Business",
          price: 40000,
          status: "submitted"
        },
        {
          id: "test-salary-y3",
          date: `${currentYear-3}-05-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "3 Years Ago Salary",
          price: 100000,
          status: "submitted"
        },
        {
          id: "test-salary-y4",
          date: `${currentYear-4}-05-15`,
          declarationType: "income",
          incomeType: "SALARY",
          declarationName: "4 Years Ago Salary",
          price: 90000,
          status: "submitted"
        }
      ];
      
      // Ê£ÄÊü•ÊµãËØïÊï∞ÊçÆÁöÑÊó•Êúü
      console.log("ÊµãËØïÊï∞ÊçÆÊó•ÊúüÁ§∫‰æã:", {
        testDate1: this.formData[0].date,
        testDateType: typeof this.formData[0].date,
        parsedTestDate: new Date(this.formData[0].date).toString()
      });
      
      console.log(`Generated ${this.formData.length} test data`);
      this.processFormData();
    },
    
    // Generate list of available years from form data
    generateAvailableYears() {
      const yearSet = new Set();
      const currentYear = new Date().getFullYear();
      
      // Include current year and past 10 years
      for (let i = 0; i <= 10; i++) {
        yearSet.add(currentYear - i);
      }
      
      // Also add any years from form data that might be outside this range
      this.formData.forEach(form => {
        if (form.date) {
          const year = new Date(form.date).getFullYear();
          if (!isNaN(year)) {
            yearSet.add(year);
          }
        }
      });
      
      // Convert to array and sort
      this.availableYears = Array.from(yearSet).sort((a, b) => b - a);
      
      // Set default start/end years if not already set
      if (!this.filterStartYear || !this.filterEndYear) {
        this.resetYearDefaults();
      }
    },
    
    // Reset year range defaults
    resetYearDefaults() {
      const currentYear = new Date().getFullYear();
      
      // Default to last 5 years (current + past 4)
      this.filterStartYear = currentYear - 4;
      this.filterEndYear = currentYear;
    },
    
    // Á°Æ‰øùÂπ¥‰ªΩËåÉÂõ¥Âú®ÂÖÅËÆ∏ÁöÑÊúÄÂ§ßËåÉÂõ¥ÂÜÖ (1-10Âπ¥)
    validateYearRange() {
      // Á°Æ‰øùËá≥Â∞ëÈÄâÊã©1Âπ¥
      if (this.filterEndYear < this.filterStartYear) {
        this.filterEndYear = this.filterStartYear;
      }
      
      // Á°Æ‰øùÊúÄÂ§öÈÄâÊã©10Âπ¥
      if (this.filterEndYear - this.filterStartYear > this.maxYearsRange - 1) {
        this.filterEndYear = this.filterStartYear + this.maxYearsRange - 1;
      }
    },
    
    // Process form data into categories for dashboard display
    processFormData() {
      this.generateAvailableYears();
      this.validateYearRange();
      
      // ÂÖàÊ∏ÖÁ©∫Êï∞ÁªÑÔºåÁ°Æ‰øùÂÆåÂÖ®ÈáçÊñ∞Âä†ËΩΩ
      this.taxLiabilities = [];
      this.paymentHistory = [];
      this.outstandingItems = [];
      
      // Ê∑ªÂä†È¢ùÂ§ñÊó•Âøó
      console.log(`ÂºÄÂßãÂ§ÑÁêÜË°®ÂçïÊï∞ÊçÆÔºåÂΩìÂâçËßÜÂõæÊ®°Âºè: ${this.viewMode}`);
      
      // Â§ÑÁêÜÊï∞ÊçÆ
      this.processTaxLiabilities();
      this.processPaymentHistory();
      this.processOutstandingItems();
      
      console.log(`Ë°®ÂçïÊï∞ÊçÆÂ§ÑÁêÜÂÆåÊàêÔºåÁîüÊàê‰∫Ü ${this.taxLiabilities.length} Êù°Á®éÂä°Ë¥üÂÄ∫ËÆ∞ÂΩï`);
      
      // Clear any existing charts first
      if (this.incomeChart) {
        try {
          this.incomeChart.destroy();
        } catch (e) {
          console.error("Failed to destroy income chart:", e);
        }
        this.incomeChart = null;
      }
      
      if (this.expenseChart) {
        try {
          this.expenseChart.destroy();
        } catch (e) {
          console.error("Failed to destroy expense chart:", e);
        }
        this.expenseChart = null;
      }
      
      // Ensure containers are ready before refreshing charts
      this.$nextTick(() => {
        this.ensureChartCanvasReady();
        
        // Now refresh charts with a slight delay
        setTimeout(() => {
          this.refreshCharts();
        }, 200);
      });
      
      this.error = null; // Clear any error messages
    },
    
    // ËÆ°ÁÆóËñ™ËµÑÁ®éÊ¨æÔºå‰ΩøÁî®Èò∂Ê¢ØÁ®éÁéá
    calculateIncomeTax(amount, incomeType) {
      // ÈªòËÆ§‰ΩøÁî®OTHERÁ±ªÂûãÁöÑÁ®éÁéá
      let typeConfig = this.INCOME_TYPES.OTHER;
      
      // Â¶ÇÊûúÊèê‰æõ‰∫ÜÊî∂ÂÖ•Á±ªÂûãÂπ∂‰∏îÂ≠òÂú®ÂØπÂ∫îÈÖçÁΩÆÔºåÂàô‰ΩøÁî®ËØ•Á±ªÂûãÁöÑÈÖçÁΩÆ
      if (incomeType && this.INCOME_TYPES[incomeType]) {
        typeConfig = this.INCOME_TYPES[incomeType];
      }
      
      // Â¶ÇÊûúÊî∂ÂÖ•Á±ªÂûãÊòØËñ™ËµÑÔºå‰ΩøÁî®Èò∂Ê¢ØÁ®éÁéáËÆ°ÁÆó
      if (incomeType === 'SALARY' && typeConfig.thresholds) {
        let tax = 0;
        
        // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÊúàÂ∫¶Êî∂ÂÖ• (‰Ωé‰∫éÂπ¥Â∫¶ÊúÄ‰ΩéÈò∂Ê¢ØÁ®éÁéáÁöÑ1/6)
        const isLikelyMonthlyIncome = amount < (typeConfig.thresholds[1]?.min || 18200) / 6;
        
        // Â¶ÇÊûú‰ºº‰πéÊòØÊúàÊî∂ÂÖ•‰∏îÂ∞è‰∫éÂÖçÁ®éÈ¢ùÁöÑÊúàÂÄºÔºåËøîÂõû0
        if (isLikelyMonthlyIncome && amount < (typeConfig.thresholds[1]?.min || 18200) / 12) {
          return 0;
        }
        
        // ÂØπ‰∫éÊúàÂ∫¶Êî∂ÂÖ•ÔºåÊàë‰ª¨ÈúÄË¶ÅÂπ¥ÂåñÂêéÂÜçËÆ°ÁÆóÔºåÁÑ∂ÂêéÈô§‰ª•12ÂæóÂà∞ÊúàÂ∫¶Á®éÊ¨æ
        if (isLikelyMonthlyIncome) {
          // Âπ¥ÂåñÊî∂ÂÖ•
          const annualizedAmount = amount * 12;
          let taxableAmount = annualizedAmount;
          
          // ÈÅçÂéÜÊØè‰∏™Á®éÁéáÈò∂Ê¢Ø
          for (const threshold of typeConfig.thresholds) {
            if (taxableAmount <= 0) break;
            
            const taxableInThisBracket = Math.min(
              taxableAmount,
              threshold.max - threshold.min
            );
            
            if (taxableInThisBracket > 0) {
              tax += taxableInThisBracket * threshold.rate;
              taxableAmount -= taxableInThisBracket;
            }
          }
          
          // ËøîÂõûÊúàÂ∫¶Á®éÊ¨æ
          return tax / 12;
        } else {
          // ÂØπ‰∫éÂπ¥Â∫¶ÊàñÂÖ∂‰ªñÊî∂ÂÖ•ÔºåÁõ¥Êé•ËÆ°ÁÆó
          let remainingAmount = amount;
          
          // ÈÅçÂéÜÊØè‰∏™Á®éÁéáÈò∂Ê¢Ø
          for (const threshold of typeConfig.thresholds) {
            if (remainingAmount <= 0) break;
            
            const taxableInThisBracket = Math.min(
              remainingAmount,
              threshold.max - threshold.min
            );
            
            if (taxableInThisBracket > 0) {
              tax += taxableInThisBracket * threshold.rate;
              remainingAmount -= taxableInThisBracket;
            }
          }
          
          return tax;
        }
      }
      
      // ÂØπ‰∫éÂÖ∂‰ªñÁ±ªÂûãÊî∂ÂÖ•Ôºå‰ΩøÁî®Âõ∫ÂÆöÁ®éÁéá
      return amount * typeConfig.taxRate;
    },
    
    // ËÆ°ÁÆóÊäïËµÑÊî∂Áõä
    calculateInvestmentReturn(amount, investmentType) {
      // ÈªòËÆ§‰ΩøÁî®INVESTMENTÁ±ªÂûãÁöÑÈÖçÁΩÆ
      let typeConfig = this.INCOME_TYPES.INVESTMENT;
      
      // Â¶ÇÊûúÊèê‰æõ‰∫ÜÁâπÂÆöÊäïËµÑÁ±ªÂûãÂπ∂‰∏îÂ≠òÂú®ÂØπÂ∫îÈÖçÁΩÆÔºåÂàô‰ΩøÁî®ËØ•Á±ªÂûãÁöÑÈÖçÁΩÆ
      if (investmentType && this.INCOME_TYPES[investmentType]) {
        typeConfig = this.INCOME_TYPES[investmentType];
      }
      
      // ËÆ°ÁÆóÊäïËµÑÊî∂ÁõäÔºàÁÆÄÂåñÊ®°ÂûãÔºåÂÆûÈôÖÂ∫îÊ†πÊçÆÊäïËµÑÊúüÈôêÁ≠âÂõ†Á¥†ËÆ°ÁÆóÔºâ
      const returnRate = typeConfig.returnRate || 0.05; // ÈªòËÆ§5%Êî∂ÁõäÁéá
      return amount * returnRate;
    },
    
    // ËÆ°ÁÆó‰ø°Áî®Âà©ÊÅØ
    calculateCreditInterest(amount, creditType) {
      // ÈªòËÆ§‰ΩøÁî®REFUNDÁ±ªÂûãÁöÑÈÖçÁΩÆ
      let typeConfig = this.CREDIT_TYPES.REFUND;
      
      // Â¶ÇÊûúÊèê‰æõ‰∫ÜÁâπÂÆö‰ø°Áî®Á±ªÂûãÂπ∂‰∏îÂ≠òÂú®ÂØπÂ∫îÈÖçÁΩÆÔºåÂàô‰ΩøÁî®ËØ•Á±ªÂûãÁöÑÈÖçÁΩÆ
      if (creditType && this.CREDIT_TYPES[creditType]) {
        typeConfig = this.CREDIT_TYPES[creditType];
      }
      
      // ËÆ°ÁÆóÂà©ÊÅØÔºàÁÆÄÂåñÊ®°ÂûãÔºåÂÆûÈôÖÂ∫îÊ†πÊçÆÊåÅÊúâÊúüÈôêÁ≠âÂõ†Á¥†ËÆ°ÁÆóÔºâ
      const interestRate = typeConfig.interestRate || 0;
      return amount * interestRate;
    },
    
    // ËÆ°ÁÆóÊâ£Èô§È¢ù
    calculateDeduction(amount, deductionType) {
      // ÈªòËÆ§‰ΩøÁî®BUSINESS_EXPENSEÁ±ªÂûãÁöÑÈÖçÁΩÆ
      let typeConfig = this.DEDUCTION_TYPES.BUSINESS_EXPENSE;
      
      // Â¶ÇÊûúÊèê‰æõ‰∫ÜÁâπÂÆöÊâ£Èô§Á±ªÂûãÂπ∂‰∏îÂ≠òÂú®ÂØπÂ∫îÈÖçÁΩÆÔºåÂàô‰ΩøÁî®ËØ•Á±ªÂûãÁöÑÈÖçÁΩÆ
      if (deductionType && this.DEDUCTION_TYPES[deductionType]) {
        typeConfig = this.DEDUCTION_TYPES[deductionType];
      }
      
      // ËÆ°ÁÆóÂèØÊâ£Èô§ÈáëÈ¢ù
      const deductionRate = typeConfig.deductionRate || 0;
      return amount * deductionRate;
    },
    
    // Ëé∑ÂèñÁâπÂÆöÁ±ªÂûãÁöÑÈ¢úËâ≤
    getTypeColor(type, category = 'INCOME') {
      const colors = {
        INCOME: {
          SALARY: 'rgba(75, 192, 192, 0.6)',
          BUSINESS: 'rgba(54, 162, 235, 0.6)',
          INVESTMENT: 'rgba(153, 102, 255, 0.6)',
          OTHER: 'rgba(201, 203, 207, 0.6)'
        },
        CREDIT: {
          REFUND: 'rgba(75, 192, 192, 0.6)',
          REIMBURSEMENT: 'rgba(54, 162, 235, 0.6)',
          INTEREST: 'rgba(153, 102, 255, 0.6)'
        },
        DEDUCTION: {
          BUSINESS_EXPENSE: 'rgba(255, 99, 132, 0.6)',
          EDUCATION: 'rgba(255, 159, 64, 0.6)',
          CHARITY: 'rgba(255, 205, 86, 0.6)',
          MEDICAL: 'rgba(75, 192, 192, 0.6)'
        }
      };
      
      if (category && colors[category] && colors[category][type]) {
        return colors[category][type];
      }
      
      // Default colors if not found
      const defaultColors = {
        INCOME: 'rgba(75, 192, 192, 0.6)',
        CREDIT: 'rgba(54, 162, 235, 0.6)',
        DEDUCTION: 'rgba(255, 99, 132, 0.6)'
      };
      
      return defaultColors[category] || 'rgba(201, 203, 207, 0.6)';
    },
    
    // Process tax liabilities from form data
    processTaxLiabilities() {
      console.log(`ÊâßË°åprocessTaxLiabilitiesÔºåÂΩìÂâçËßÜÂõæÊ®°Âºè: ${this.viewMode}`);
      
      // Á°Æ‰øùtaxLiabilitiesÊòØ‰∏Ä‰∏™Êñ∞Êï∞ÁªÑÔºåÈÅøÂÖçÂºïÁî®ÈóÆÈ¢ò
      this.taxLiabilities = [];
      
      // Get the current date for calculating due status
      const currentDate = new Date();
      const currentYear = new Date().getFullYear();
      
      // ËÆ°ÁÆóÂêÑÁ±ªÂûãÊî∂ÂÖ•ÁöÑÊÄªÂíåÔºåÁî®‰∫éËÆ°ÁÆóÁ®éÊ¨æ
      const incomesByType = {};
      const deductionsByType = {};
      
      // È¶ñÂÖàÁªüËÆ°ÂêÑÁ±ªÂûãÊî∂ÂÖ•ÂíåÊâ£Èô§
      let processedCount = 0;
      this.formData.forEach(form => {
        // Ê†áÂáÜÂåñÊó•Êúü
        const standardizedDate = this.standardizeDate(form.date);
        if (standardizedDate) {
          form.standardizedDate = standardizedDate;
          
          // Ê£ÄÊü•ÊòØÂê¶Âú®Á≠õÈÄâËåÉÂõ¥ÂÜÖ
          const formYear = standardizedDate.getFullYear();
          const formMonth = standardizedDate.getMonth();
          const formQuarter = Math.floor(formMonth / 3) + 1;
          
          // Ë∑≥Ëøá‰∏çÂú®Á≠õÈÄâËåÉÂõ¥ÂÜÖÁöÑËÆ∞ÂΩï
          if (this.viewMode === 'yearly') {
            if (formYear < this.filterStartYear || formYear > this.filterEndYear) {
              return; // ‰∏çÂú®Âπ¥‰ªΩËåÉÂõ¥ÂÜÖÔºåË∑≥Ëøá
            }
          } else if (this.viewMode === 'quarterly') {
            if (formYear !== this.filterQuarterYear) {
              return; // ‰∏çÂú®ÈÄâÂÆöÂπ¥‰ªΩÔºåË∑≥Ëøá
            }
            
            if (this.filterQuarter !== 'all' && formQuarter.toString() !== this.filterQuarter) {
              return; // ‰∏çÂú®ÈÄâÂÆöÂ≠£Â∫¶ÔºåË∑≥Ëøá
            }
          }
        }
        
        // Âè™Â§ÑÁêÜÊèê‰∫§Áä∂ÊÄÅÁöÑË°®Âçï
        if (form.status === 'submitted' || form.status === this.FORM_STATUS.SUBMITTED) {
          processedCount++;
          
          // Â§ÑÁêÜÊî∂ÂÖ•Ë°®Âçï
          if (form.declarationType === 'income' || form.declaration_type === 'income') {
            // Ëé∑ÂèñÊî∂ÂÖ•Á±ªÂûãÔºåÈªòËÆ§‰∏∫OTHER
            const incomeType = form.incomeType || 'OTHER';
            
            // ÂàùÂßãÂåñÊî∂ÂÖ•Á±ªÂûãËÆ°Êï∞Âô®
            if (!incomesByType[incomeType]) {
              incomesByType[incomeType] = 0;
            }
            
            // Á¥ØËÆ°ËØ•Á±ªÂûãÁöÑÊî∂ÂÖ•
            incomesByType[incomeType] += (form.price || 0);
          }
          
          // Â§ÑÁêÜÊâ£Èô§Ë°®Âçï
          else if (form.declarationType === 'deduction' || form.declaration_type === 'deduction') {
            // Ëé∑ÂèñÊâ£Èô§Á±ªÂûãÔºåÈªòËÆ§‰∏∫BUSINESS_EXPENSE
            const deductionType = form.deductionType || 'BUSINESS_EXPENSE';
            
            // ÂàùÂßãÂåñÊâ£Èô§Á±ªÂûãËÆ°Êï∞Âô®
            if (!deductionsByType[deductionType]) {
              deductionsByType[deductionType] = 0;
            }
            
            // Á¥ØËÆ°ËØ•Á±ªÂûãÁöÑÊâ£Èô§
            deductionsByType[deductionType] += (form.price || 0);
          }
        }
      });
      
      console.log(`Â§ÑÁêÜ‰∫Ü ${processedCount} ‰∏™Ë°®ÂçïËÆ∞ÂΩïËøõË°åÁ®éË¥üËÆ°ÁÆó`);
      
      // ËÆ°ÁÆóÊâ£Èô§ÂêéÁöÑÂ∫îÁ®éÊî∂ÂÖ•
      let totalDeductions = 0;
      for (const [deductionType, amount] of Object.entries(deductionsByType)) {
        const deductibleAmount = this.calculateDeduction(amount, deductionType);
        totalDeductions += deductibleAmount;
      }
      
      // Ê†πÊçÆÊî∂ÂÖ•ËÆ°ÁÆóÂ∫îÁº¥Á®éÊ¨æÂπ∂Ê∑ªÂä†Âà∞Ë¥üÂÄ∫ÂàóË°®
      for (const [incomeType, totalIncome] of Object.entries(incomesByType)) {
        // ËÆ°ÁÆóËØ•Á±ªÂûãÊî∂ÂÖ•Âç†ÊÄªÊî∂ÂÖ•ÁöÑÊØî‰æã
        const totalAllIncome = Object.values(incomesByType).reduce((sum, amount) => sum + amount, 0);
        const incomeRatio = totalIncome / totalAllIncome;
        
        // ÊåâÊØî‰æãÂàÜÈÖçÊâ£Èô§È¢ù
        const applicableDeduction = totalDeductions * incomeRatio;
        
        // ËÆ°ÁÆóÂ∫îÁ®éÊî∂ÂÖ•ÂíåÁ®éÊ¨æ
        const taxableIncome = Math.max(0, totalIncome - applicableDeduction);
        const taxAmount = this.calculateIncomeTax(taxableIncome, incomeType);
        
        // ÂàõÂª∫ÂØπÂ∫îÁöÑÁ®éÂä°Ë¥üÂÄ∫È°π
        if (taxAmount > 0) {
          // ËÆæÁΩÆÂà∞ÊúüÊó•‰∏∫ÂΩìÂâçÊó•ÊúüÂêé30Â§©
          const dueDate = new Date();
          dueDate.setDate(dueDate.getDate() + 30);
          
          // Á°ÆÂÆöÁ®éÊ¨æÊèèËø∞ÔºåÊ†πÊçÆÊî∂ÂÖ•Âà§Êñ≠ÊòØÊúàÂ∫¶ËøòÊòØÂπ¥Â∫¶Á®é
          const isLikelyMonthlyIncome = incomeType === 'SALARY' && 
              taxableIncome < (this.INCOME_TYPES.SALARY.thresholds[1]?.min || 18200) / 6;
          
          const taxDescription = isLikelyMonthlyIncome 
              ? `Monthly ${this.INCOME_TYPES[incomeType]?.label || 'Income'} Tax` 
              : `${this.INCOME_TYPES[incomeType]?.label || 'Income'} Tax`;
          
          // ËÆ°ÁÆóÁä∂ÊÄÅ
          let status = 'upcoming';
          let statusText = 'Upcoming';
          
          // ÂàõÂª∫ÂîØ‰∏ÄIDÔºåÂåÖÂê´ËßÜÂõæÊ®°Âºè‰ø°ÊÅØÔºåÁ°Æ‰øù‰∏ç‰ºöÂõ†‰∏∫ËßÜÂõæÂàáÊç¢ËÄå‰∏¢Â§±
          const taxId = `tax-${incomeType.toLowerCase()}-${currentDate.getTime()}-${this.viewMode}`;
          
          this.taxLiabilities.push({
            id: taxId,
            name: taxDescription,
            amount: taxAmount,
            dueDate: dueDate,
            status: status,
            statusText: statusText,
            color: this.INCOME_TYPES[incomeType]?.color || 'rgba(255, 99, 132, 0.6)'
          });
        }
        
        // ÂØπ‰∫éÊäïËµÑÁ±ªÂûãÔºåÂ¢ûÂä†ÊΩúÂú®Êî∂ÁõäÈ¢ÑÊµã
        if (incomeType === 'INVESTMENT') {
          const returnAmount = this.calculateInvestmentReturn(totalIncome, incomeType);
          
          // È¢ÑÊµãÊî∂ÁõäÊó•Êúü‰∏∫ÂΩìÂâçÊó•ÊúüÂêé90Â§©
          const projectedDate = new Date();
          projectedDate.setDate(projectedDate.getDate() + 90);
          
          this.taxLiabilities.push({
            id: `return-investment-${currentDate.getTime()}-${this.viewMode}`,
            name: 'Projected Investment Return',
            amount: -returnAmount, // Ë¥üÂÄºË°®Á§∫Êî∂Áõä
            dueDate: projectedDate,
            status: 'upcoming',
            statusText: 'Projected',
            color: this.INCOME_TYPES.INVESTMENT.color
          });
        }
      }
      
      // ÁîüÊàêÂ≠£Â∫¶‰º∞ÁÆóÁ®éÈ°πÔºåÁ°Æ‰øùÊâÄÊúâÂ≠£Â∫¶ÈÉΩÊúâ‰º∞ÁÆóÁ®é
      if (this.viewMode === 'yearly' || this.filterQuarter === 'all') {
        // ‰∏∫ÂΩìÂâçÂíå‰∏ã‰∏ÄÂπ¥ËÆ°ÁÆóÂ≠£Â∫¶‰º∞ÁÆóÁ®é
        const taxYears = [currentYear];
        if (currentYear + 1 <= this.filterEndYear) {
          taxYears.push(currentYear + 1);
        }
        
        taxYears.forEach(year => {
          // Á°Æ‰øùÂπ¥‰ªΩÂú®ËøáÊª§ËåÉÂõ¥ÂÜÖ
          if (year >= this.filterStartYear && year <= this.filterEndYear) {
            // Q1 (due April 15)
            const q1Tax = this.calculateEstimatedQuarterlyTax(1);
            if (q1Tax > 0) {
              const q1DueDate = new Date(year, 3, 15); // April 15
              
              // ËÆ°ÁÆóÁä∂ÊÄÅ
              let status = 'upcoming';
              let statusText = 'Upcoming';
              
              if (q1DueDate < currentDate) {
                status = 'overdue';
                statusText = 'Overdue';
              } else if (q1DueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
                status = 'due-soon';
                statusText = 'Due Soon';
              }
              
              this.taxLiabilities.push({
                id: `estimated-tax-q1-${year}-${this.viewMode}`,
                name: `Q1 ${year} Estimated Tax`,
                amount: q1Tax,
                dueDate: q1DueDate,
                status: status,
                statusText: statusText,
                color: 'rgba(255, 152, 0, 0.6)'
              });
            }
            
            // Q2 (due June 15)
            const q2Tax = this.calculateEstimatedQuarterlyTax(2);
            if (q2Tax > 0) {
              const q2DueDate = new Date(year, 5, 15); // June 15
              
              // ËÆ°ÁÆóÁä∂ÊÄÅ
              let status = 'upcoming';
              let statusText = 'Upcoming';
              
              if (q2DueDate < currentDate) {
                status = 'overdue';
                statusText = 'Overdue';
              } else if (q2DueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
                status = 'due-soon';
                statusText = 'Due Soon';
              }
              
              this.taxLiabilities.push({
                id: `estimated-tax-q2-${year}-${this.viewMode}`,
                name: `Q2 ${year} Estimated Tax`,
                amount: q2Tax,
                dueDate: q2DueDate,
                status: status,
                statusText: statusText,
                color: 'rgba(255, 152, 0, 0.6)'
              });
            }
            
            // Q3 (due September 15)
            const q3Tax = this.calculateEstimatedQuarterlyTax(3);
            if (q3Tax > 0) {
              const q3DueDate = new Date(year, 8, 15); // September 15
              
              // ËÆ°ÁÆóÁä∂ÊÄÅ
              let status = 'upcoming';
              let statusText = 'Upcoming';
              
              if (q3DueDate < currentDate) {
                status = 'overdue';
                statusText = 'Overdue';
              } else if (q3DueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
                status = 'due-soon';
                statusText = 'Due Soon';
              }
              
              this.taxLiabilities.push({
                id: `estimated-tax-q3-${year}-${this.viewMode}`,
                name: `Q3 ${year} Estimated Tax`,
                amount: q3Tax,
                dueDate: q3DueDate,
                status: status,
                statusText: statusText,
                color: 'rgba(255, 152, 0, 0.6)'
              });
            }
            
            // Q4 (due January 15 next year)
            const q4Tax = this.calculateEstimatedQuarterlyTax(4);
            if (q4Tax > 0) {
              const q4DueDate = new Date(year + 1, 0, 15); // January 15 next year
              
              // ËÆ°ÁÆóÁä∂ÊÄÅ
              let status = 'upcoming';
              let statusText = 'Upcoming';
              
              if (q4DueDate < currentDate) {
                status = 'overdue';
                statusText = 'Overdue';
              } else if (q4DueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
                status = 'due-soon';
                statusText = 'Due Soon';
              }
              
              this.taxLiabilities.push({
                id: `estimated-tax-q4-${year}-${this.viewMode}`,
                name: `Q4 ${year} Estimated Tax`,
                amount: q4Tax,
                dueDate: q4DueDate,
                status: status,
                statusText: statusText,
                color: 'rgba(255, 152, 0, 0.6)'
              });
            }
          }
        });
      } else if (this.viewMode === 'quarterly' && this.filterQuarter !== 'all') {
        // ÈíàÂØπÁâπÂÆöÂ≠£Â∫¶ÁöÑËßÜÂõæÔºåÂè™Ê∑ªÂä†ËØ•Â≠£Â∫¶ÁöÑ‰º∞ÁÆóÁ®é
        const quarter = parseInt(this.filterQuarter);
        const year = this.filterQuarterYear;
        
        // Á°ÆÂÆöÂ≠£Â∫¶Á®éÂ∫îËØ•ÁöÑÂà∞ÊúüÊó•
        let dueDateMonth, dueDateDay;
        switch(quarter) {
          case 1: dueDateMonth = 3; dueDateDay = 15; break; // Q1: April 15
          case 2: dueDateMonth = 5; dueDateDay = 15; break; // Q2: June 15
          case 3: dueDateMonth = 8; dueDateDay = 15; break; // Q3: September 15
          case 4: dueDateMonth = 0; dueDateDay = 15; // Q4: January 15 next year (month 0 = January)
          break;
        }
        
        const dueDate = quarter === 4 
          ? new Date(year + 1, dueDateMonth, dueDateDay)
          : new Date(year, dueDateMonth, dueDateDay);
        
        const quarterlyTax = this.calculateEstimatedQuarterlyTax(quarter);
        if (quarterlyTax > 0) {
          // ËÆ°ÁÆóÁä∂ÊÄÅ
          let status = 'upcoming';
          let statusText = 'Upcoming';
          
          if (dueDate < currentDate) {
            status = 'overdue';
            statusText = 'Overdue';
          } else if (dueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
            status = 'due-soon';
            statusText = 'Due Soon';
          }
          
          this.taxLiabilities.push({
            id: `estimated-tax-q${quarter}-${year}-${this.viewMode}`,
            name: `Q${quarter} ${year} Estimated Tax`,
            amount: quarterlyTax,
            dueDate: dueDate,
            status: status,
            statusText: statusText,
            color: 'rgba(255, 152, 0, 0.6)'
          });
        }
      }
      
      // Â§ÑÁêÜÁé∞Êúâ‰ø°Áî®ÂíåÈÄÄÁ®éÈ°πÁõÆÔºåÂ¢ûÂä†Âà©ÊÅØËÆ°ÁÆó
      this.formData.forEach(form => {
        if (form.status === 'submitted' || form.status === this.FORM_STATUS.SUBMITTED) {
          // Â§ÑÁêÜ‰ø°Áî®Á±ªÂûãÔºàÈÄÄÁ®é„ÄÅÊä•ÈîÄÁ≠âÔºâ
          if (form.declarationType === 'credit' || form.declaration_type === 'credit' || 
              form.declarationType === 'refund' || form.declaration_type === 'refund') {
            
            // Ëé∑Âèñ‰ø°Áî®Á±ªÂûã
            const creditType = form.creditType || 'REFUND';
            const amount = form.price || 0;
            
            // ËÆ°ÁÆóÂà©ÊÅØÔºàÂ¶ÇÊûúÈÄÇÁî®Ôºâ
            const interestAmount = this.calculateCreditInterest(amount, creditType);
            
            // Â¶ÇÊûúÊúâÂà©ÊÅØÔºåÊ∑ªÂä†Âà∞Ë¥üÂÄ∫ÂàóË°®ÔºàË¥üÂÄºË°®Á§∫Êî∂ÁõäÔºâ
            if (interestAmount > 0) {
              // Âà©ÊÅØÈ¢ÑËÆ°Âà∞Ë¥¶Êó•Êúü‰∏∫ÂΩìÂâçÊó•ÊúüÂêé60Â§©
              const interestDate = new Date();
              interestDate.setDate(interestDate.getDate() + 60);
              
              this.taxLiabilities.push({
                id: `interest-${creditType.toLowerCase()}-${currentDate.getTime()}`,
                name: `${this.CREDIT_TYPES[creditType]?.label || 'Credit'} Interest`,
                amount: -interestAmount, // Ë¥üÂÄºË°®Á§∫Êî∂Áõä
                dueDate: interestDate,
                status: 'upcoming',
                statusText: 'Projected',
                color: this.CREDIT_TYPES[creditType]?.color || 'rgba(75, 192, 192, 0.6)'
              });
            }
          }
        }
      });
      
      // Â§ÑÁêÜÁé∞ÊúâÁ®éÂä°Ë¥üÂÄ∫Ë°®Âçï - ‰∏çÊ†πÊçÆËßÜÂõæÊ®°ÂºèËøáÊª§ÔºåÁ°Æ‰øùÂú®‰ªª‰ΩïËßÜÂõæ‰∏ãÈÉΩÊòæÁ§∫ÊâÄÊúâÁ®éÂä°Ë¥üÂÄ∫
      let liabilityCount = 0;
      this.formData.forEach(form => {
        // Filter for draft forms or tax payment forms - Ê≥®ÊÑèËøôÈáå‰∏çÊ†πÊçÆËßÜÂõæÊ®°ÂºèËøáÊª§
        if (form.status === 'draft' || 
            form.declaration_type === 'tax' || 
            form.declarationType === 'tax' || 
            form.declaration_type === 'liability' || 
            form.declarationType === 'liability') {
          
          liabilityCount++;
          
          // ‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•Êúü
          const standardizedDate = this.standardizeDate(form.date);
          const formDate = standardizedDate || new Date();
          const dueDate = form.due_date ? this.standardizeDate(form.due_date) : new Date(formDate.getTime() + 30*24*60*60*1000);
          
          // Calculate status
          let status = 'upcoming';
          let statusText = 'Upcoming';
          
          if (dueDate < currentDate) {
            status = 'overdue';
            statusText = 'Overdue';
          } else if (dueDate.getTime() - currentDate.getTime() < 7*24*60*60*1000) {
            status = 'due-soon';
            statusText = 'Due Soon';
          }
          
          // ÂàÜÈÖçÂêàÈÄÇÁöÑÈ¢úËâ≤
          let color = 'rgba(255, 99, 132, 0.6)'; // ÈªòËÆ§Á∫¢Ëâ≤
          if (form.taxType && this.INCOME_TYPES[form.taxType]) {
            color = this.INCOME_TYPES[form.taxType].color;
          }
          
          // ÂàõÂª∫ÂîØ‰∏ÄIDÔºåÂåÖÂê´ËßÜÂõæÊ®°Âºè‰ø°ÊÅØÔºåÁ°Æ‰øù‰∏ç‰ºöÂõ†‰∏∫ËßÜÂõæÂàáÊç¢ËÄå‰∏¢Â§±
          const liabilityId = form.id + `-${this.viewMode}`;
          
          this.taxLiabilities.push({
            id: liabilityId,
            name: form.declaration_name || form.declarationName || 'Tax Liability',
            amount: form.price || 0,
            dueDate: dueDate,
            status: status,
            statusText: statusText,
            formData: form,
            color: color
          });
        }
      });
      
      // Â§ÑÁêÜÁé∞Êúâ‰ø°Áî®Á±ªÂûãË°®ÂçïÔºåÊ∑ªÂä†Âà∞Ë¥üÂÄ∫ÂàóË°®ÔºàË¥üÂÄºË°®Á§∫Êî∂ÁõäÔºâ
      this.formData.forEach(form => {
        if ((form.status === 'submitted' || form.status === this.FORM_STATUS.SUBMITTED) &&
            (form.declarationType === 'credit' || form.declaration_type === 'credit')) {
          
          // Ëé∑Âèñ‰ø°Áî®Á±ªÂûã
          const creditType = form.creditType || 'REFUND';
          const amount = form.price || 0;
          
          // ‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•Êúü
          const standardizedDate = this.standardizeDate(form.date);
          const formDate = standardizedDate || new Date();
          
          // ËÆæÁΩÆÂà∞Ë¥¶Êó•Êúü‰∏∫ÂΩìÂâçÊó•ÊúüÂêé14Â§©
          const receivableDate = new Date(formDate);
          receivableDate.setDate(receivableDate.getDate() + 14);
          
          // ÂàõÂª∫ÂîØ‰∏ÄIDÔºåÂåÖÂê´ËßÜÂõæÊ®°Âºè‰ø°ÊÅØ
          const creditId = `credit-${form.id}-${this.viewMode}`;
          
          // Ê∑ªÂä†Â∑≤ÊúâÁöÑ‰ø°Áî®ËÆ∞ÂΩïÂà∞Ë¥üÂÄ∫ÂàóË°®ÔºåÊòæÁ§∫‰∏∫Êú™Êù•Êî∂Áõä
          this.taxLiabilities.push({
            id: creditId,
            name: `${this.CREDIT_TYPES[creditType]?.label || 'Credit'} Receivable`,
            amount: -amount, // Ë¥üÂÄºË°®Á§∫Êî∂Áõä
            dueDate: receivableDate,
            status: 'upcoming',
            statusText: 'Upcoming',
            formData: form,
            color: this.CREDIT_TYPES[creditType]?.color || 'rgba(75, 192, 192, 0.6)'
          });
        }
      });
      
      // Sort liabilities by due date (earliest first)
      this.taxLiabilities.sort((a, b) => {
        if (a.dueDate instanceof Date && b.dueDate instanceof Date) {
          return a.dueDate - b.dueDate;
        }
        return 0; // Â¶ÇÊûúÊó•Êúü‰∏çÊòØÊúâÊïàÁöÑDateÂØπË±°ÔºåÂàô‰∏çÊîπÂèòÈ°∫Â∫è
      });
      
      console.log(`Â§ÑÁêÜ‰∫Ü ${liabilityCount} Êù°Á®éÂä°Ë¥üÂÄ∫ËÆ∞ÂΩïÔºåÁîüÊàê‰∫Ü ${this.taxLiabilities.length} Êù°Ë¥üÂÄ∫ÊòæÁ§∫È°πÔºåÂΩìÂâçËßÜÂõæÊ®°Âºè: ${this.viewMode}`);
      
      // Âº∫Âà∂Êõ¥Êñ∞ÂìçÂ∫îÂºèÊï∞ÊçÆ
      this.$nextTick(() => {
        console.log(`Á®éÂä°Ë¥üÂÄ∫Êï∞ÊçÆÊõ¥Êñ∞ÂêéÊ£ÄÊü•: ÊÄªÊï∞=${this.taxLiabilities.length}, ÂΩìÂâçÊòæÁ§∫Êï∞=${this.currentTaxLiabilities.length}`);
      });
      
      // Ê£ÄÊü•Âç≥Â∞ÜÂà∞ÊúüÁöÑË¥üÂÄ∫ÔºåÂèëÈÄÅÈÄöÁü•ÊèêÈÜí
      this.sendUpcomingLiabilitiesNotifications();
    },
    
    // Êñ∞Â¢ûÊñπÊ≥ïÔºöÂèëÈÄÅÁ®éÂä°Ë¥üÂÄ∫ÈÄöÁü•
    sendUpcomingLiabilitiesNotifications() {
      // ‰ªéuseAuthËé∑ÂèñÂΩìÂâçÁî®Êà∑‰ø°ÊÅØ
      const currentUser = localStorage.getItem('user');
      if (!currentUser) {
        console.log('User not logged in, skipping notifications');
        return;
      }
      
      const userObj = JSON.parse(currentUser);
      if (!userObj.isLoggedIn) {
        console.log('User not logged in, skipping notifications');
        return;
      }
      
      // Ëé∑ÂèñÁî®Êà∑IDÊàñEmail‰Ωú‰∏∫ÂîØ‰∏ÄÊ†áËØÜ
      const userId = userObj.email || 'anonymous';
      
      // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶ÊòØÁÆ°ÁêÜÂëòÔºåÂ¶ÇÊûúÊòØÔºåÂàôË∑≥ËøáÁ®éÂä°ÊèêÈÜí
      if (userObj.isAdmin) {
        console.log('User is admin, skipping tax liability notifications');
        return;
      }
      
      // Â¶ÇÊûúÊú™Ëé∑ÂèñtoastÊàñnotificationsÊúçÂä°ÔºåÂàôË∑≥Ëøá
      if (!this.toast || !this.notifications) {
        console.log('Toast or notification service unavailable, skipping notifications');
        return;
      }
      
      // ÂºÄÂèëÁéØÂ¢É‰∏≠Ê£ÄÊü•ÔºöË∑≥ËøáÂèëÈÄÅ2025Âπ¥Âèä‰ª•ÂêéÁöÑÊú™Êù•ÈÄöÁü•
      const currentDate = new Date();
      const currentYear = currentDate.getFullYear();
      if (this.taxLiabilities.some(l => {
        const liabilityYear = l.dueDate ? l.dueDate.getFullYear() : 0;
        return liabilityYear > currentYear + 1; // Ë∑≥ËøáË∂ÖËøáÂΩìÂâçÂπ¥‰ªΩ+1Âπ¥ÁöÑÈÄöÁü•
      })) {
        console.log('Detected test data with future dates, skipping notifications');
        return;
      }
      
      // ÂèëÈÄÅÈÄöÁü•ÂâçÂÖàÊ£ÄÊü•Ôºö‰ΩøÁî®currentTaxLiabilitiesËÆ°ÁÆóÂ±ûÊÄßËé∑ÂèñÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫
      const liabilities = this.currentTaxLiabilities || [];
      
      if (liabilities.length > 0) {
        // Âª∂ËøüÂèëÈÄÅÈÄöÁü•
        setTimeout(() => {
          // Ê±áÊÄªÊÄªÈáëÈ¢ù
          const totalAmount = liabilities.reduce((sum, item) => sum + item.amount, 0);
          
          // ÂèëÈÄÅÊ±áÊÄªÈÄöÁü•
          this.toast.warning(`You have ${liabilities.length} tax ${liabilities.length === 1 ? 'liability' : 'liabilities'} totaling ${this.formatCurrency(totalAmount)}`, {
            title: 'Tax Liability Alert',
            duration: 8000
          });
          
          // Ê∑ªÂä†ËØ¶ÁªÜÈÄöÁü•Âà∞ÈÄöÁü•‰∏≠ÂøÉÔºåÂåÖÂê´Áî®Êà∑ID
          liabilities.forEach(liability => {
            const daysLeft = Math.ceil((liability.dueDate - currentDate) / (24 * 60 * 60 * 1000));
            const dueText = daysLeft <= 7 
              ? `due in ${daysLeft} days` 
              : `due on ${this.formatDate(liability.dueDate)}`;
            
            this.notifications.addNotification({
              userId: userId,
              title: 'Tax Liability Alert',
              message: `${liability.name}: ${this.formatCurrency(liability.amount)}, ${dueText}`,
              time: new Date(),
              read: false
            });
          });
          
          // ËÆ∞ÂΩï‰ªäÂ§©Â∑≤ÁªèÂêëËØ•Áî®Êà∑ÂèëÈÄÅËøáÊèêÈÜí
          const today = `${currentDate.getFullYear()}-${currentDate.getMonth() + 1}-${currentDate.getDate()}`;
          const storageKey = `sentDashboardReminders_${userId}`;
          const sentDashboardReminders = JSON.parse(localStorage.getItem(storageKey) || '{}');
          sentDashboardReminders[today] = true;
          localStorage.setItem(storageKey, JSON.stringify(sentDashboardReminders));
          console.log(`Tax liability reminders sent to user ${userId} and recorded for today`);
        }, 1500);
      }
    },
    
    // Process payment history from form data
    processPaymentHistory() {
      this.paymentHistory = [];
      console.log("ÂºÄÂßãÂ§ÑÁêÜÊîØ‰ªòÂéÜÂè≤...");
      
      this.formData.forEach(form => {
        const standardizedDate = this.standardizeDate(form.date);
        if (standardizedDate) {
          form.standardizedDate = standardizedDate;
        }
        
        if (form.status === 'submitted' || form.status === this.FORM_STATUS.SUBMITTED) {
          // Êñ∞Â¢ûÔºöÂ¶ÇÊûúË°®ÂçïÁ±ªÂûãÊòØ 'credit' Êàñ 'refund'ÔºåÂàô‰∏çÂú®ÊîØ‰ªòÂéÜÂè≤‰∏≠ÊòæÁ§∫ÔºåËøô‰∫õÂ∞ÜÊòæÁ§∫Âú® Outstanding Items ‰∏≠
          const declType = form.declarationType || form.declaration_type;
          if (declType === 'credit' || declType === 'refund') {
            console.log(`Ë°®Âçï ${form.id} Á±ªÂûã‰∏∫ ${declType}ÔºåÂ∞Ü‰∏çÂú® Financial Transactions History ‰∏≠ÊòæÁ§∫ÔºåÊîπÂú® Financial Items & Tax Estimates ‰∏≠ÊòæÁ§∫„ÄÇ`);
            return; // Ë∑≥ËøáÊ∑ªÂä†Âà∞ paymentHistory
          }

          // Ë∑≥Ëøá‰∏çÂú®ÂΩìÂâçËøáÊª§ËåÉÂõ¥ÂÜÖÁöÑÊï∞ÊçÆ
          if (form.standardizedDate) {
            const formYear = form.standardizedDate.getFullYear();
            const formMonth = form.standardizedDate.getMonth();
            const formQuarter = Math.floor(formMonth / 3) + 1;
            
            // Ê£ÄÊü•ÊòØÂê¶Âú®Á≠õÈÄâËåÉÂõ¥ÂÜÖ
            if (this.viewMode === 'yearly') {
              // Âπ¥ËßÜÂõæ: Ê£ÄÊü•Âπ¥‰ªΩÊòØÂê¶Âú®ÈÄâÂÆöËåÉÂõ¥ÂÜÖ
              if (formYear < this.filterStartYear || formYear > this.filterEndYear) {
                console.log(`Ë°®Âçï ${form.id} Êó•Êúü ${form.date} ‰∏çÂú®Âπ¥‰ªΩÁ≠õÈÄâËåÉÂõ¥ÂÜÖ(${this.filterStartYear}-${this.filterEndYear})ÔºåÂ∑≤Ë∑≥Ëøá`);
                return; // ‰∏çÂú®ËøáÊª§ËåÉÂõ¥ÂÜÖÔºåË∑≥Ëøá
              }
            } else if (this.viewMode === 'quarterly') {
              // Â≠£Â∫¶ËßÜÂõæ: Ê£ÄÊü•Âπ¥‰ªΩÂíåÂ≠£Â∫¶
              if (formYear !== this.filterQuarterYear) {
                console.log(`Ë°®Âçï ${form.id} Êó•Êúü ${form.date} ‰∏çÂú®Â≠£Â∫¶Á≠õÈÄâÂπ¥‰ªΩÂÜÖ(${this.filterQuarterYear})ÔºåÂ∑≤Ë∑≥Ëøá`);
                return; // ‰∏çÂú®ÈÄâÂÆöÂπ¥‰ªΩÔºåË∑≥Ëøá
              }
              
              // Â¶ÇÊûúÊåáÂÆö‰∫ÜÁâπÂÆöÂ≠£Â∫¶ÔºåÊ£ÄÊü•ÊòØÂê¶ÂåπÈÖç
              if (this.filterQuarter !== 'all' && formQuarter.toString() !== this.filterQuarter) {
                console.log(`Ë°®Âçï ${form.id} Êó•Êúü ${form.date} ‰∏çÂú®Â≠£Â∫¶Á≠õÈÄâÂ≠£Â∫¶ÂÜÖ(Q${this.filterQuarter})ÔºåÂ∑≤Ë∑≥Ëøá`);
                return; // ‰∏çÂú®ÈÄâÂÆöÂ≠£Â∫¶ÔºåË∑≥Ëøá
              }
            }
          } else {
            console.log(`Ë≠¶Âëä: Ë°®Âçï ${form.id} Êó†Ê≥ïËß£ÊûêÊó•Êúü "${form.date}"`);
          }
          
          // Â§ÑÁêÜÊî∂ÂÖ•Á±ªÂûãÔºåÁ°Æ‰øùÊ≠£Á°ÆËØÜÂà´salary
          if (form.declarationType === 'income' || form.declaration_type === 'income') {
            // Ê£ÄÊü•Êî∂ÂÖ•Á±ªÂûãÁöÑÂêÑÁßçÊÉÖÂÜµ
            const description = (form.declarationName || form.declaration_name || '').toLowerCase();
            
            // Ê£ÄÊü•Ë°®ÂçïÂêçÁß∞ÂíåÊèèËø∞ÊòØÂê¶ÂåÖÂê´salaryÂÖ≥ÈîÆÂ≠ó
            if (description.includes('salary') || description.includes('wage') || description.includes('pay')) {
              console.log(`Ê£ÄÊµãÂà∞Â∑•ËµÑÂÖ≥ÈîÆÂ≠óÂú®ÊèèËø∞‰∏≠: "${description}"`);
              form.incomeType = 'SALARY';
            }
            
            // Â¶ÇÊûúÂ∑≤ÊúâincomeTypeÔºåÁ°Æ‰øùÊ†áÂáÜÂåñ‰∏∫Â§ßÂÜô
            if (form.incomeType) {
              // Á°Æ‰øùËΩ¨‰∏∫Â§ßÂÜô
              form.incomeType = form.incomeType.toUpperCase();
              console.log(`Â§ÑÁêÜÊî∂ÂÖ•Ë°®Âçï: ${form.id}, Êî∂ÂÖ•Á±ªÂûãÂ∑≤Ê†áÂáÜÂåñ‰∏∫: ${form.incomeType}`);
            } else {
              // Â¶ÇÊûúÊ≤°ÊúâÊåáÂÆöÊî∂ÂÖ•Á±ªÂûã‰ΩÜÂêçÁß∞ÂåÖÂê´Â∑•ËµÑÁõ∏ÂÖ≥ËØçÊ±áÔºåËÆæÁΩÆ‰∏∫SALARY
              form.incomeType = 'SALARY';
              console.log(`‰∏∫Ë°®ÂçïÊåáÂÆöÈªòËÆ§Êî∂ÂÖ•Á±ªÂûãSALARY: ${form.id}`);
            }
          }
          
          // Determine payment type (credit or debit)
          let paymentType = 'debit';
          let flowType = '';
          
          // Á°Æ‰øùÊâÄÊúâincomeÁ±ªÂûãÈÉΩÊòØcredit
          if (form.declarationType === 'income' || form.declaration_type === 'income' ||
              form.declarationType === 'credit' || form.declaration_type === 'credit' ||
              form.declarationType === 'refund' || form.declaration_type === 'refund' ||
              (form.declarationName && form.declarationName.toLowerCase().includes('salary'))) {
            paymentType = 'credit';
            flowType = 'Income';
          } else {
            paymentType = this.determinePaymentType(form);
            flowType = paymentType === 'credit' ? 'Income' : 'Expense';
          }
          
          // Create a more descriptive payment description based on form type
          let description = form.declaration_name || form.declarationName || 'Tax Payment';
          let categoryLabel = '';
          
          // Â§ÑÁêÜÊî∂ÂÖ•Á±ªÂûãÊ†áÁ≠æ
          if (form.declarationType === 'income' && form.incomeType) {
            // Â∑≤ÁªèÂú®‰∏äÈù¢Á°Æ‰øù‰∫ÜincomeType‰∏∫Â§ßÂÜô
            categoryLabel = this.getTypeLabel(form.incomeType, 'INCOME');
            description = `${categoryLabel}: ${description}`;
          } else if (form.declarationType === 'credit' && form.creditType) {
            categoryLabel = this.getTypeLabel(form.creditType, 'CREDIT');
            description = `${categoryLabel}: ${description}`;
          } else if (form.declarationType === 'deduction' && form.deductionType) {
            categoryLabel = this.getTypeLabel(form.deductionType, 'DEDUCTION');
            description = `${categoryLabel}: ${description}`;
          }
          
          // Create a clear transaction type label
          let transactionType = '';
          if (form.declarationType === 'income') {
            transactionType = 'Income';
          } else if (form.declarationType === 'credit') {
            // Âè™Âú®Financial Transactions History‰∏≠ÊòæÁ§∫CreditÁ±ªÂûãÔºå‰∏çÂú®Outstanding Items‰∏≠ÊòæÁ§∫
            transactionType = 'Tax Credit';
          } else if (form.declarationType === 'deduction') {
            transactionType = 'Deductible Expense';
          } else if (form.declarationType === 'investment') {
            transactionType = 'Investment';
          } else {
            transactionType = flowType;
          }
          
          // ÈÅøÂÖçÂú®Êî∂ÂÖ•ÂéÜÂè≤‰∏≠ÈáçÂ§çÊ∑ªÂä†Â∑≤Âú®Outstanding Items‰∏≠ÊòæÁ§∫ÁöÑCreditÁ±ªÂûãË°®Âçï
          // CreditÁ±ªÂûãÁöÑË°®ÂçïÂè™ÊòæÁ§∫Âú®Financial Transactions History‰∏≠
          this.paymentHistory.push({
            id: form.id,
            date: form.standardizedDate || new Date(), // ‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•Êúü
            rawDate: form.date, // ‰øùÁïôÂéüÂßãÊó•Êúü‰ª•‰æøË∞ÉËØï
            description: description,
            amount: form.price || 0,
            type: paymentType,
            transactionType: transactionType,
            categoryLabel: categoryLabel,
            formData: form
          });
          
          console.log(`Ê∑ªÂä†ËÆ∞ÂΩï: ID=${form.id}, Ê†áÂáÜÂåñÊó•Êúü=${form.standardizedDate ? form.standardizedDate.toISOString() : 'N/A'}, ÂéüÂßãÊó•Êúü=${form.date}, Á±ªÂûã=${transactionType}, ÊèèËø∞=${description}`);
        }
      });
      
      // Sort payment history by date (most recent first)
      // ÊéíÂ∫èÁé∞Âú®‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•ÊúüÔºåÂ∫îËØ•‰∏ç‰ºöÊúâÈóÆÈ¢ò
      this.paymentHistory.sort((a, b) => {
        // ‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•ÊúüËøõË°åÊéíÂ∫è
        if (a.date && b.date) {
          return b.date - a.date;
        }
        
        // ÂêéÂ§áÊéíÂ∫èÊú∫Âà∂
        return a.id > b.id ? -1 : 1;
      });
      
      // ÊâìÂç∞ÊîØ‰ªòÂéÜÂè≤ÁöÑÊéíÂ∫èÁªìÊûú
      console.log("ÊéíÂ∫èÂêéÁöÑÊîØ‰ªòÂéÜÂè≤ËÆ∞ÂΩï(Ââç5Êù°):");
      this.paymentHistory.slice(0, 5).forEach(item => {
        console.log(`ID=${item.id}, Ê†áÂáÜÂåñÊó•Êúü=${item.date instanceof Date ? item.date.toISOString() : item.date}, ÂéüÂßãÊó•Êúü=${item.rawDate}, ÊèèËø∞=${item.description}`);
      });
      
      // ÊâìÂç∞Â§ÑÁêÜÂêéÁöÑpayment history
      console.log(`Â§ÑÁêÜ‰∫Ü ${this.paymentHistory.length} Êù°ÊîØ‰ªòÂéÜÂè≤ËÆ∞ÂΩï`);
      this.paymentHistory.filter(item => 
        item.formData && item.formData.declarationType === 'income'
      ).forEach(item => {
        console.log(`ÊîØ‰ªòÂéÜÂè≤ËÆ∞ÂΩï: ${item.id}, Êî∂ÂÖ•Á±ªÂûã: ${item.formData.incomeType}, Êó•Êúü: ${item.date}`);
      });
    },
    
    // Process outstanding credits/debits from form data with filtering
    processOutstandingItems() {
      this.outstandingItems = [];
      
      this.formData.forEach(form => {
        if (form.status === 'submitted' || form.status === this.FORM_STATUS.SUBMITTED) {
          const standardizedDate = this.standardizeDate(form.date);
          
          if (standardizedDate) {
            const formYear = standardizedDate.getFullYear();
            const formMonth = standardizedDate.getMonth();
            const formQuarter = Math.floor(formMonth / 3) + 1;
            
            if (this.viewMode === 'yearly') {
              if (formYear < this.filterStartYear || formYear > this.filterEndYear) {
                return;
              }
            } else if (this.viewMode === 'quarterly') {
              if (formYear !== this.filterQuarterYear) {
                return;
              }
              if (this.filterQuarter !== 'all' && formQuarter.toString() !== this.filterQuarter) {
                return;
              }
            }
          } else {
            if (this.viewMode === 'quarterly' && this.filterQuarter !== 'all') {
              return;
            }
          }
          
          if (form.declarationType === 'deduction' || form.declaration_type === 'deduction') {
            const deductionType = form.deductionType || 'BUSINESS_EXPENSE';
            const deductibleAmount = this.calculateDeduction(form.price || 0, deductionType);
            const deductionLabel = this.getTypeLabel(deductionType, 'DEDUCTION');
            const description = `${deductionLabel}: ${form.declarationName || 'Tax Deduction'}`;
            this.outstandingItems.push({
              id: form.id,
              type: 'Credit',
              description: description,
              amount: deductibleAmount,
              category: 'DEDUCTION',
              itemType: deductionType,
              date: form.standardizedDate || form.date // Prefer standardized, fallback to original
            });
          }
          // ÊÅ¢Â§çÂ∞Ü 'credit' (Â¶ÇÈÄÄÁ®é) Á±ªÂûãË°®ÂçïÊ∑ªÂä†Âà∞ outstandingItems ÁöÑÈÄªËæë
          else if (form.declarationType === 'credit' || form.declaration_type === 'credit') {
            const creditType = form.creditType || 'REFUND'; 
            const creditLabel = this.getTypeLabel(creditType, 'CREDIT');
            const description = `${creditLabel}: ${form.declarationName || 'Tax Credit'}`;
            this.outstandingItems.push({
              id: form.id,
              type: 'Credit',
              description: description,
              amount: form.price || 0,
              category: 'CREDIT',
              itemType: creditType,
              date: form.standardizedDate || form.date // Prefer standardized, fallback to original
            });
            
            // ÊöÇÊó∂‰∏çÂú®Ê≠§Â§ÑÈáçÂ§çËÆ°ÁÆóÂíåÊ∑ªÂä†È¢ÑËÆ°Âà©ÊÅØÔºåÂõ†‰∏∫Âà©ÊÅØÁöÑÈ¢ÑËÆ°Â∑≤ÁªèÁªü‰∏ÄÂú® processTaxLiabilities ‰∏≠Â§ÑÁêÜÂπ∂ÂèØËÉΩÊòæÁ§∫Âú® Current Tax Liabilities
            // ÊàñËÄÖÂà©ÊÅØÁöÑÈÄªËæëÂèØ‰ª•Êõ¥Ê∏ÖÊô∞Âú∞ÂàÜÁ¶ª
          }
        }
      });
      
      // Ê∑ªÂä†Áé∞ÊúâÁ®éÂä°Ë¥üÂÄ∫Âà∞Outstanding ItemsÔºåÁ°Æ‰øù‰∏éCurrent Tax Liabilities‰øùÊåÅ‰∏ÄËá¥
      // ËøôÊ†∑ÈÅøÂÖç‰∫ÜÁî®Êà∑ÁúãÂà∞‰∏§‰∏™‰∏çÂêåÁöÑÂÄº
      this.taxLiabilities.forEach(liability => {
        // Âè™Ê∑ªÂä†ÂÆûÈôÖÁöÑÁ®éÂä°Ë¥üÂÄ∫(‰∏çÂåÖÊã¨Ë¥üÂÄºÁöÑÊî∂ÁõäÈ°π)ÔºåÈÅøÂÖçÈáçÂ§ç
        if (liability.amount > 0 && liability.name.includes('Estimated Tax')) {
          this.outstandingItems.push({
            id: `outstanding-${liability.id}`,
            type: 'Debit',
            description: liability.name,
            amount: liability.amount,
            category: 'TAX',
            itemType: 'QUARTERLY',
            date: liability.dueDate
          });
        }
      });
      
      // ÊéíÈô§ÊóßÁöÑÁã¨Á´ãËÆ°ÁÆóÁöÑÂ≠£Â∫¶‰º∞ÁÆóÁ®éÊñπÊ≥ïÔºå‰ΩøÁî®taxLiabilities‰∏≠ÁöÑÊï∞ÊçÆ‰ª£Êõø
      /*
      // Add estimated quarterly tax payments
      const currentYear = new Date().getFullYear();
      
      if (this.filterStartYear <= currentYear && this.filterEndYear >= currentYear) {
        
        // Q1 (due April 15)
        const q1Tax = this.calculateEstimatedQuarterlyTax(1);
        if (q1Tax > 0) {
          this.outstandingItems.push({
            id: `q1-${currentYear}`,
            type: 'Debit',
            description: `Q1 ${currentYear} Estimated Tax`,
            amount: q1Tax,
            category: 'TAX',
            itemType: 'QUARTERLY',
            date: new Date(currentYear, 3, 15) // April 15
          });
        }
        
        // Q2 (due June 15)
        const q2Tax = this.calculateEstimatedQuarterlyTax(2);
        if (q2Tax > 0) {
          this.outstandingItems.push({
            id: `q2-${currentYear}`,
            type: 'Debit',
            description: `Q2 ${currentYear} Estimated Tax`,
            amount: q2Tax,
            category: 'TAX',
            itemType: 'QUARTERLY',
            date: new Date(currentYear, 5, 15) // June 15
          });
        }
        
        // Q3 (due September 15)
        const q3Tax = this.calculateEstimatedQuarterlyTax(3);
        if (q3Tax > 0) {
          this.outstandingItems.push({
            id: `q3-${currentYear}`,
            type: 'Debit',
            description: `Q3 ${currentYear} Estimated Tax`,
            amount: q3Tax,
            category: 'TAX',
            itemType: 'QUARTERLY',
            date: new Date(currentYear, 8, 15) // September 15
          });
        }
        
        // Q4 (due January 15 next year)
        const q4Tax = this.calculateEstimatedQuarterlyTax(4);
        if (q4Tax > 0) {
          this.outstandingItems.push({
            id: `q4-${currentYear}`,
            type: 'Debit',
            description: `Q4 ${currentYear} Estimated Tax`,
            amount: q4Tax,
            category: 'TAX',
            itemType: 'QUARTERLY',
            date: new Date(currentYear + 1, 0, 15) // January 15 next year
          });
        }
      }
      */
      
      // Sort by date (most recent first)
      this.outstandingItems.sort((a, b) => {
        const dateA = a.date ? new Date(a.date) : new Date();
        const dateB = b.date ? new Date(b.date) : new Date();
        return dateA - dateB; // Sort by date ascending
      });
    },
    
    // Calculate estimated quarterly tax based on income data
    calculateEstimatedQuarterlyTax(quarter) {
      // Get income for the relevant quarter
      const currentYear = new Date().getFullYear();
      let totalIncome = 0;
      let totalTax = 0;
      
      // Define quarter date ranges
      const quarterRanges = {
        1: { start: new Date(currentYear, 0, 1), end: new Date(currentYear, 2, 31) },
        2: { start: new Date(currentYear, 3, 1), end: new Date(currentYear, 5, 30) },
        3: { start: new Date(currentYear, 6, 1), end: new Date(currentYear, 8, 30) },
        4: { start: new Date(currentYear, 9, 1), end: new Date(currentYear, 11, 31) }
      };
      
      // ÊåâÊî∂ÂÖ•Á±ªÂûãÂàÜÁ±ªÁªüËÆ°
      const incomesByType = {};
      
      // Find income in this quarter
      this.formData.forEach(form => {
        const formDate = form.date ? new Date(form.date) : null;
        if (formDate && 
            formDate >= quarterRanges[quarter].start && 
            formDate <= quarterRanges[quarter].end &&
            (form.declaration_type === 'income' || form.declarationType === 'income')) {
          
          const incomeType = form.incomeType || 'OTHER';
          const amount = form.price || 0;
          
          if (!incomesByType[incomeType]) {
            incomesByType[incomeType] = 0;
          }
          
          incomesByType[incomeType] += amount;
          totalIncome += amount;
        }
      });
      
      // ËÆ°ÁÆóÊØèÁßçÊî∂ÂÖ•Á±ªÂûãÁöÑÁ®éÊ¨æ
      for (const [incomeType, amount] of Object.entries(incomesByType)) {
        totalTax += this.calculateIncomeTax(amount, incomeType);
      }
      
      // Â¶ÇÊûúÊ≤°ÊúâÂü∫‰∫éÊî∂ÂÖ•Á±ªÂûãÁöÑÁ®éÊ¨æ‰ø°ÊÅØÔºåÂõûÈÄÄÂà∞ÂéüÊù•ÁöÑÁÆÄÂçï‰º∞ÁÆó
      if (totalTax === 0 && totalIncome > 0) {
        totalTax = totalIncome * 0.25; // ÁÆÄÂçï‰º∞ÁÆó: Êî∂ÂÖ•ÁöÑ25%
      }
      
      return totalTax;
    },
    
    // Helper method to determine if a form represents a credit or debit
    determinePaymentType(form) {
      // Default to debit
      let type = 'debit';
      
      // Check declaration type
      const declarationType = form.declaration_type || form.declarationType || '';
      
      // Income and credits should be marked as credit (money coming in)
      if (declarationType.toLowerCase().includes('income') || 
          declarationType.toLowerCase().includes('refund') || 
          declarationType.toLowerCase().includes('credit') || 
          declarationType.includes('reimburse')) {
        type = 'credit';
      }
      
      // Check declaration name as backup
      const declarationName = form.declaration_name || form.declarationName || '';
      if (declarationName.toLowerCase().includes('income') ||
          declarationName.toLowerCase().includes('salary') ||
          declarationName.toLowerCase().includes('refund') || 
          declarationName.toLowerCase().includes('credit') || 
          declarationName.toLowerCase().includes('reimburse')) {
        type = 'credit';
      }
      
      return type;
    },
    
    // Refresh charts based on processed data
    refreshCharts() {
      // Reset chart instances
      this.destroyCharts();
      
      // Check if we have data to display
      this.hasIncomeData = this.paymentHistory && this.paymentHistory.filter(item => 
        item.formData && 
        (item.formData.declarationType === 'income' || item.formData.declaration_type === 'income')
      ).length > 0;
      
      console.log(`Êî∂ÂÖ•Êï∞ÊçÆÊ£ÄÊü•: hasIncomeData = ${this.hasIncomeData}`);
      
      // Á°Æ‰øùÂè™Ë¶ÅÊúâ‰ªª‰ΩïÊï∞ÊçÆÔºåÊàë‰ª¨Â∞±ÊòæÁ§∫Ë¥¢Âä°Ë∂ãÂäøÂõæ
      this.hasExpenseData = this.paymentHistory && this.paymentHistory.length > 0;
      
      // Âº∫Âà∂ËÆæÁΩÆ‰∏∫true‰ª•‰æø‰∫éÊµãËØïÂíåË∞ÉËØï
      this.hasIncomeData = true;
      
      // Schedule the chart initialization after current tick to ensure DOM is updated
      this.$nextTick(() => {
        this.resetChartCanvases();
        
        // Only initialize charts if we have data
        if (this.hasIncomeData || this.hasExpenseData) {
          this.initCharts();
        }
      });
    },
    
    // Initialize charts with available data
    initCharts() {
      // Context for charting
      let labels = [];
      
      if (this.viewMode === 'yearly') {
        // For yearly view, use years as labels
        for (let y = this.filterStartYear; y <= this.filterEndYear; y++) {
          labels.push(y.toString());
        }
      } else {
        // For quarterly view, use quarters as labels (without year)
        for (let q = 1; q <= 4; q++) {
          labels.push(`Q${q}`);
        }
      }
      
      // Income Chart - Enhanced for different income types
      const incomeCtx = document.getElementById('income-chart');
      if (incomeCtx && this.hasIncomeData) {
        // Create the income data structure by income type
        const incomeDatasets = this.prepareChartDatasets('INCOME');
        
        this.incomeChart = new Chart(incomeCtx, {
          type: 'bar',
          data: {
            labels: labels,
            datasets: incomeDatasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                stacked: true,
                title: {
                  display: true,
                  text: this.viewMode === 'yearly' ? 'Year' : 'Quarter'
                }
              },
              y: {
                stacked: true,
                title: {
                  display: true,
                  text: 'Amount ($)'
                },
                ticks: {
                  callback: function(value) {
                    return '$' + value.toLocaleString();
                  }
                }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      label += new Intl.NumberFormat('en-US', { 
                        style: 'currency', 
                        currency: 'USD'
                      }).format(context.parsed.y);
                    }
                    return label;
                  }
                }
              },
              legend: {
                position: 'top',
                labels: {
                  boxWidth: 15,
                  padding: 15
                }
              },
              title: {
                display: true,
                text: this.viewMode === 'yearly' ? 'Income Breakdown by Year' : `Income Breakdown by Quarter (${this.filterQuarterYear})`
              }
            }
          }
        });
      }
      
      // Financial Trends Chart - Line chart showing income, expense and net income trends
      const expenseCtx = document.getElementById('expense-chart');
      if (expenseCtx && this.hasExpenseData) {
        // Get financial trends datasets
        const trendsDatasets = this.prepareChartDatasets('FINANCIAL_TRENDS');
        
        this.expenseChart = new Chart(expenseCtx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: trendsDatasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
              mode: 'index',
              intersect: false,
            },
            scales: {
              x: {
                title: {
                  display: true,
                  text: this.viewMode === 'yearly' ? 'Year' : 'Quarter'
                }
              },
              y: {
                title: {
                  display: true,
                  text: 'Amount ($)'
                },
                ticks: {
                  callback: function(value) {
                    return '$' + value.toLocaleString();
                  }
                }
              }
            },
            plugins: {
              tooltip: {
                callbacks: {
                  label: function(context) {
                    let label = context.dataset.label || '';
                    if (label) {
                      label += ': ';
                    }
                    if (context.parsed.y !== null) {
                      // Show values with appropriate formatting
                      const formattedValue = new Intl.NumberFormat('en-US', { 
                        style: 'currency', 
                        currency: 'USD'
                      }).format(context.parsed.y);
                      
                      return label + formattedValue;
                    }
                    return label;
                  }
                }
              },
              legend: {
                position: 'top',
                labels: {
                  boxWidth: 15,
                  padding: 15,
                  usePointStyle: true,
                  pointStyle: 'circle'
                }
              },
              title: {
                display: true,
                text: this.viewMode === 'yearly' ? 'Financial Trends by Year' : `Financial Trends by Quarter (${this.filterQuarterYear})`
              }
            }
          }
        });
      }
    },
    
    // Helper method to prepare chart datasets by category
    prepareChartDatasets(category) {
      const datasets = [];
      const dataByType = {};
      
      // Labels array based on view mode
      const labels = [];
      
      if (this.viewMode === 'yearly') {
        // Years in filter range
        for (let y = this.filterStartYear; y <= this.filterEndYear; y++) {
          labels.push(y);
        }
      } else {
        // Quarters for quarterly view (current year)
        for (let q = 1; q <= 4; q++) {
          labels.push(`Q${q}`);
        }
      }
      
      // Process data based on category
      let itemsToProcess = [];
      
      // Ê†πÊçÆ‰∏çÂêåÂõæË°®Á±ªÂûãËé∑ÂèñÊï∞ÊçÆ
      if (category === 'INCOME') {
        itemsToProcess = this.paymentHistory.filter(item => 
          item.formData && 
          (item.formData.declarationType === 'income' || 
           item.formData.declaration_type === 'income'));
        
        // Ë∞ÉËØï: ÊâìÂç∞Êî∂ÂÖ•È°πÁöÑÊï∞ÈáèÂíåÁ±ªÂûã
        console.log(`‰∏∫ÂõæË°®Â§ÑÁêÜ ${itemsToProcess.length} ‰∏™Êî∂ÂÖ•È°π`);
        itemsToProcess.forEach(item => {
          console.log(`ÂõæË°®Êî∂ÂÖ•È°π: ${item.id}, Êî∂ÂÖ•Á±ªÂûã: ${item.formData.incomeType || 'UNDEFINED'}, ÊèèËø∞: ${item.description}, Ê†áÂáÜÂåñÊó•Êúü: ${item.date instanceof Date ? item.date.toISOString().substring(0, 10) : item.date}`);
        });
      } else if (category === 'CREDIT') {
        itemsToProcess = this.outstandingItems.filter(item => 
          item.type === 'Credit' && 
          (item.category === 'CREDIT' || item.category === 'INTEREST'));
      } else if (category === 'DEDUCTION') {
        itemsToProcess = this.outstandingItems.filter(item => 
          item.category === 'DEDUCTION');
      } else if (category === 'FINANCIAL_TRENDS') {
        // Ëé∑ÂèñÊâÄÊúâÊî∂ÂÖ•ËÆ∞ÂΩï
        const incomeItems = this.paymentHistory.filter(item => 
          item.type === 'credit' && item.formData && 
          (item.formData.declarationType === 'income' || 
           item.formData.declaration_type === 'income')
        );
        
        // Ëé∑ÂèñÊâÄÊúâÊîØÂá∫ËÆ∞ÂΩï
        const expenseItems = this.paymentHistory.filter(item => 
          item.type === 'debit' || 
          (item.formData && item.formData.declarationType === 'deduction')
        );
        
        // Â§ÑÁêÜÊî∂ÂÖ•ËÆ∞ÂΩï - Á°Æ‰øù‰ΩøÁî®Ê†áÂáÜÂåñÊó•Êúü
        incomeItems.forEach(item => {
          itemsToProcess.push({
            ...item,
            trendType: 'INCOME',
            // dateÂ∑≤ÁªèÊòØÊ†áÂáÜÂåñÂêéÁöÑÊó•ÊúüÂØπË±°
          });
        });
        
        // Â§ÑÁêÜÊîØÂá∫ËÆ∞ÂΩï - Á°Æ‰øù‰ΩøÁî®Ê†áÂáÜÂåñÊó•Êúü
        expenseItems.forEach(item => {
          itemsToProcess.push({
            ...item,
            trendType: 'EXPENSE',
            // dateÂ∑≤ÁªèÊòØÊ†áÂáÜÂåñÂêéÁöÑÊó•ÊúüÂØπË±°
          });
        });
        
        console.log(`Ë¥¢Âä°Ë∂ãÂäø: Â§ÑÁêÜ ${incomeItems.length} ‰∏™Êî∂ÂÖ•È°πÂíå ${expenseItems.length} ‰∏™ÊîØÂá∫È°π`);
      }
      
      // ÂØπ‰∫éË¥¢Âä°Ë∂ãÂäøÂõæË°®ÔºåÊàë‰ª¨ÈúÄË¶ÅÁâπÊÆäÂ§ÑÁêÜ
      if (category === 'FINANCIAL_TRENDS') {
        // ÊåâÊúüÈó¥(Âπ¥‰ªΩÊàñÂ≠£Â∫¶)ÂàÜÁªÑÁöÑÊï∞ÊçÆ
        const periodData = {};
        
        // ÂàùÂßãÂåñÊâÄÊúâÊúüÈó¥
        labels.forEach(period => {
          periodData[period] = {
            income: 0,
            expense: 0,
            credit: 0,
            debit: 0,
            // taxRefund: 0, // ÁßªÈô§ taxRefundÔºåÂêàÂπ∂Âà∞ credit
            taxLiability: 0 
          };
        });
        
        // Â§ÑÁêÜ paymentHistoryÔºåÂå∫ÂàÜ income Âíå credit (Â¶Ç tax refund)
        this.paymentHistory.forEach(item => {
          if (!item.date || !(item.date instanceof Date)) {
            console.warn(`Ë∑≥ËøáË¥¢Âä°Ë∂ãÂäøÈ°π (paymentHistory ${item.id}): Êó†ÊïàÊó•Êúü`);
            return;
          }
          
          const itemDate = item.date;
          const year = itemDate.getFullYear();
          
          if (this.viewMode === 'yearly' && (year < this.filterStartYear || year > this.filterEndYear)) {
            return;
          }
          
          const quarter = Math.floor(itemDate.getMonth() / 3) + 1;
          const periodKey = this.viewMode === 'yearly' ? year : `Q${quarter}`;
          
          if (!periodData[periodKey]) {
            periodData[periodKey] = { income: 0, expense: 0, credit: 0, debit: 0, taxLiability: 0 };
          }
          
          const amount = Math.abs(item.amount || 0);
          if (item.formData) {
            const declType = item.formData.declarationType || item.formData.declaration_type;
            if (declType === 'income') {
              periodData[periodKey].income += amount;
            } else if (declType === 'credit' || declType === 'refund') { // Tax refunds and other direct credits
              periodData[periodKey].credit += amount;
            } else if (item.type === 'debit' || declType === 'deduction' || declType === 'tax' || declType === 'liability') {
              periodData[periodKey].expense += amount; // Expenses, deductions, tax payments, liabilities treated as expense flow for chart
            }
          } else if (item.type === 'debit') { // Fallback for items without formData if they are debits
             periodData[periodKey].expense += amount;
          } else if (item.type === 'credit') { // Fallback for general credits without specific formData declarationType
             // If it's a credit from paymentHistory without formData, decide if it's income-like or credit-like.
             // For now, let's assume general credits from payment history (if not 'income' declType) are credit-like.
             periodData[periodKey].credit += amount;
          }
        });
        
        // Â§ÑÁêÜFinancial Items & Tax EstimatesÊï∞ÊçÆ(outstandingItems)
        this.outstandingItems.forEach(item => {
          let itemDate = null;
          if (item.date) {
            itemDate = item.date instanceof Date ? item.date : this.standardizeDate(item.date);
          } else {
            itemDate = new Date(); // Fallback, though ideally all items should have dates
          }
          
          if (!itemDate || isNaN(itemDate.getTime())) {
            console.warn(`Ë∑≥ËøáOutstandingÈ°π ${item.description}: Êó†ÊïàÊó•Êúü`);
            return;
          }
          
          const year = itemDate.getFullYear();
          
          if (this.viewMode === 'yearly' && (year < this.filterStartYear || year > this.filterEndYear)) {
            return;
          }
          
          const quarter = Math.floor(itemDate.getMonth() / 3) + 1;
          const periodKey = this.viewMode === 'yearly' ? year : `Q${quarter}`;
          
          if (!periodData[periodKey]) {
            periodData[periodKey] = { income: 0, expense: 0, credit: 0, debit: 0, taxLiability: 0 };
          }
          
          const amount = Math.abs(item.amount || 0);
          if (item.type === 'Credit') {
            periodData[periodKey].credit += amount; // Sums with credits from paymentHistory
          } else if (item.type === 'Debit') {
            // Debits from outstandingItems are typically future obligations or estimates not yet paid.
            // For 'Net Financial Position', these are 'debits'.
            // For 'Total Expenses' line, we should be careful not to double count if also in paymentHistory.
            // The 'Total Expenses' line is derived from paymentHistory (actual outflows).
            // So, outstanding 'Debit' items should primarily affect 'debit' for Net Financial Position,
            // and the 'Tax Liabilities' line if they are 'TAX' category.
            periodData[periodKey].debit += amount;
          }
        });
        
        // ‰ΩøÁî®taxLiabilitiesÊï∞ÊçÆÁîüÊàêÊõ¥ÂáÜÁ°ÆÁöÑÁ®éÂä°Ë¥üÂÄ∫Ë∂ãÂäø (Â∑≤ËøáÊª§Êéâ 'estimated tax')
        const taxLiabilityTrends = this.taxLiabilities.filter(liability => 
          liability.amount > 0 && 
          liability.dueDate instanceof Date &&
          !liability.name.toLowerCase().includes('estimated tax') 
        );
        
        taxLiabilityTrends.forEach(liability => {
          const itemDate = liability.dueDate;
          const year = itemDate.getFullYear();
          
          if (this.viewMode === 'yearly' && (year < this.filterStartYear || year > this.filterEndYear)) {
            return;
          }
          
          const quarter = Math.floor(itemDate.getMonth() / 3) + 1;
          const periodKey = this.viewMode === 'yearly' ? year : `Q${quarter}`;
          
          if (!periodData[periodKey]) {
            periodData[periodKey] = { income: 0, expense: 0, credit: 0, debit: 0, taxLiability: 0 };
          }
          
          periodData[periodKey].taxLiability = (periodData[periodKey].taxLiability || 0) + liability.amount;
        });
        
        // ÂàõÂª∫ÊÄªÊî∂ÂÖ•Êï∞ÊçÆÈõÜ
        const incomeData = labels.map(period => periodData[period]?.income || 0);
        datasets.push({
          label: 'Total Income',
          data: incomeData,
          backgroundColor: 'rgba(46, 125, 50, 0.2)',
          borderColor: 'rgba(46, 125, 50, 1)',
          borderWidth: 2,
          tension: 0.4,
          fill: false,
          pointBackgroundColor: 'rgba(46, 125, 50, 1)',
          pointRadius: 4
        });
        
        // ÂàõÂª∫ÊÄªÊîØÂá∫Êï∞ÊçÆÈõÜ
        const expenseData = labels.map(period => periodData[period]?.expense || 0);
        datasets.push({
          label: 'Total Expenses',
          data: expenseData,
          backgroundColor: 'rgba(211, 47, 47, 0.2)',
          borderColor: 'rgba(211, 47, 47, 1)',
          borderWidth: 2,
          tension: 0.4,
          fill: false,
          pointBackgroundColor: 'rgba(211, 47, 47, 1)',
          pointRadius: 4
        });
        
        // ÂàõÂª∫Á®éÂä°‰ø°Áî®(Credit)Êï∞ÊçÆÈõÜ
        const creditData = labels.map(period => periodData[period]?.credit || 0);
        datasets.push({
          label: 'Tax Credits & Deductions',
          data: creditData,
          backgroundColor: 'rgba(156, 39, 176, 0.2)',
          borderColor: 'rgba(156, 39, 176, 1)',
          borderWidth: 2,
          tension: 0.4,
          fill: false,
          pointBackgroundColor: 'rgba(156, 39, 176, 1)',
          pointRadius: 4,
          pointStyle: 'triangle'
        });
        
        // ÂàõÂª∫Á®éÂä°Ê¨†Ê¨æ(Debit)Êï∞ÊçÆÈõÜ - ‰ΩøÁî®Áõ¥Êé•‰ªétaxLiabilitiesËé∑ÂèñÁöÑÊï∞ÊçÆ
        const taxLiabilityData = labels.map(period => periodData[period]?.taxLiability || 0);
        const hasLiabilityData = taxLiabilityData.some(amount => amount > 0);
        const debitData = labels.map(period => periodData[period]?.debit || 0);
        
        datasets.push({
          label: 'Tax Liabilities',
          data: hasLiabilityData ? taxLiabilityData : debitData,
          backgroundColor: 'rgba(255, 152, 0, 0.2)',
          borderColor: 'rgba(255, 152, 0, 1)',
          borderWidth: 2,
          tension: 0.4,
          fill: false,
          pointBackgroundColor: 'rgba(255, 152, 0, 1)',
          pointRadius: 4,
          pointStyle: 'rect'
        });
        
        // ÂàõÂª∫ÂáÄÊî∂ÁõäÊï∞ÊçÆÈõÜ (Â∑≤ÂåÖÂê´ÊâÄÊúâCreditÂíåDebit)
        const netIncomeData = labels.map(period => {
          const income = periodData[period]?.income || 0;
          const expense = periodData[period]?.expense || 0;
          const credit = periodData[period]?.credit || 0;
          const debit = periodData[period]?.debit || 0;
          // const taxRefund = periodData[period]?.taxRefund || 0; // taxRefund is now part of credit
          const taxLiability = periodData[period]?.taxLiability || 0; 
          return (income + credit) - (expense + debit + taxLiability); // Updated formula
        });
        
        datasets.push({
          label: 'Net Financial Position',
          data: netIncomeData,
          backgroundColor: 'rgba(33, 150, 243, 0.2)',
          borderColor: 'rgba(33, 150, 243, 1)',
          borderWidth: 3,
          tension: 0.4,
          fill: false,
          pointBackgroundColor: 'rgba(33, 150, 243, 1)',
          pointRadius: 5,
          pointHoverRadius: 7
        });
        
        console.log('Financial trend datasets prepared:', datasets.map(d => d.label));
        return datasets;
      }
      
      // ‰ª•‰∏ã‰∏∫ÂéüÊúâÁöÑÈùûË¥¢Âä°Ë∂ãÂäøÂõæË°®Â§ÑÁêÜÈÄªËæë
      // Group data by type and period (year or quarter)
      itemsToProcess.forEach(item => {
        // Á°Æ‰øù‰ΩøÁî®Ê†áÂáÜÂåñÂêéÁöÑÊó•ÊúüÂØπË±°
        if (!item.date || !(item.date instanceof Date)) {
          console.warn(`Ë∑≥ËøáÂõæË°®È°π ${item.id}: Êó†ÊïàÊó•ÊúüÂØπË±°`);
          return;
        }
        
        const itemDate = item.date;
        const year = itemDate.getFullYear();
        
        // Skip if not in the filter range (for yearly view)
        if (this.viewMode === 'yearly' && (year < this.filterStartYear || year > this.filterEndYear)) {
          return;
        }
        
        // Get quarter for quarterly view
        const quarter = Math.floor(itemDate.getMonth() / 3) + 1;
        const periodKey = this.viewMode === 'yearly' ? year : `Q${quarter}`;
        
        // Get type based on category
        let itemType = 'OTHER';
        let displayLabel = '';
        
        if (category === 'INCOME' && item.formData) {
          // Â¢ûÂº∫ÁöÑÊî∂ÂÖ•Á±ªÂûãÊ£ÄÊµãÈÄªËæë
          let detectedType = 'OTHER';
          
          // È¶ñÂÖàÊ£ÄÊü•form‰∏≠ÊòæÂºèËÆæÁΩÆÁöÑincomeType
          if (item.formData.incomeType) {
            detectedType = item.formData.incomeType.toUpperCase();
            console.log(`‰ΩøÁî®Ë°®Âçï‰∏≠ÁöÑÊî∂ÂÖ•Á±ªÂûã: ${detectedType}`);
          }
          
          // Â¶ÇÊûúÊ≤°ÊúâÊòéÁ°ÆÁöÑÁ±ªÂûãÔºåÂ∞ùËØï‰ªéÊèèËø∞Ê£ÄÊµã
          if (detectedType === 'OTHER' || !detectedType) {
            const description = item.description.toLowerCase();
            if (description.includes('salary') || 
                description.includes('wage') || 
                description.includes('monthly pay') ||
                description.includes('fixed salary')) {
              detectedType = 'SALARY';
              console.log(`‰ªéÊèèËø∞‰∏≠Ê£ÄÊµãÂà∞Â∑•ËµÑÁ±ªÂûã: "${description}" -> SALARY`);
            } else if (description.includes('business')) {
              detectedType = 'BUSINESS';
            } else if (description.includes('investment') || description.includes('stock') || description.includes('dividend')) {
              detectedType = 'INVESTMENT';
            }
          }
          
          // Á°Æ‰øùÁ±ªÂûãÊúâÊïà
          if (detectedType && this.INCOME_TYPES[detectedType]) {
            itemType = detectedType;
          } else {
            itemType = 'OTHER';
          }
          
          // Êõ¥Êñ∞Ë°®Âçï‰∏≠ÁöÑÊî∂ÂÖ•Á±ªÂûã‰ª•Á°Æ‰øù‰∏ÄËá¥ÊÄß
          if (item.formData && itemType !== 'OTHER') {
            item.formData.incomeType = itemType;
            console.log(`Êõ¥Êñ∞Ë°®ÂçïÊî∂ÂÖ•Á±ªÂûã: ${item.id} -> ${itemType}`);
          }
          
          displayLabel = this.getTypeLabel(itemType, category);
        } else if (category === 'CREDIT') {
          itemType = item.itemType || 'REFUND';
          displayLabel = this.getTypeLabel(itemType, category);
        } else if (category === 'DEDUCTION') {
          itemType = item.itemType || 'BUSINESS_EXPENSE';
          displayLabel = this.getTypeLabel(itemType, category);
        } else if (category === 'CASHFLOW') {
          // For cash flow, use specific groupings
          if (item.flowDirection === 'inflow') {
            itemType = item.itemType || 'REFUND';
            displayLabel = `${this.getTypeLabel(itemType, 'CREDIT')} (Inflow)`;
          } else {
            itemType = item.itemType || 'BUSINESS_EXPENSE';
            displayLabel = `${this.getTypeLabel(itemType, 'DEDUCTION')} (Outflow)`;
          }
        }
        
        // Create the data structure if it doesn't exist
        const typeKey = category === 'CASHFLOW' 
          ? `${itemType}_${item.flowDirection}` 
          : itemType;
          
        if (!dataByType[typeKey]) {
          let color = '';
          if (category === 'CASHFLOW') {
            // Use green for inflows and red for outflows
            color = item.flowDirection === 'inflow' 
              ? 'rgba(46, 125, 50, 0.6)'  // Green for inflows
              : 'rgba(211, 47, 47, 0.6)'; // Red for outflows
          } else {
            color = this.getTypeColor(itemType, category);
          }
          
          dataByType[typeKey] = {
            type: itemType,
            category: category,
            label: category === 'CASHFLOW' ? displayLabel : this.getTypeLabel(itemType, category),
            color: color,
            periods: {},
            flowDirection: item.flowDirection  // Only used for CASHFLOW
          };
          
          // Initialize all periods with zero
          labels.forEach(period => {
            dataByType[typeKey].periods[period] = 0;
          });
        }
        
        // Add the amount to the appropriate period
        if (!dataByType[typeKey].periods[periodKey]) {
          dataByType[typeKey].periods[periodKey] = 0;
        }
        
        // For cash flow, we use signed values (positive or negative)
        if (category === 'CASHFLOW') {
          dataByType[typeKey].periods[periodKey] += item.amount; // Already signed appropriately
        } else {
          dataByType[typeKey].periods[periodKey] += Math.abs(item.amount);
        }
      });
      
      // ÊâìÂç∞Êï∞ÊçÆÁ±ªÂûãÂàÜÁªÑ‰ø°ÊÅØ
      console.log(`ÂõæË°®Êï∞ÊçÆÁ±ªÂûã for ${category}:`, Object.keys(dataByType).join(', '));
      
      // Convert the data to Chart.js datasets
      Object.values(dataByType).forEach(typeData => {
        const data = labels.map(period => typeData.periods[period] || 0);
        
        datasets.push({
          label: typeData.label,
          data: data,
          backgroundColor: typeData.color,
          borderColor: typeData.color.replace('0.6', '1'),
          borderWidth: 1
        });
      });
      
      return datasets;
    },
    
    // Ëé∑ÂèñÁ±ªÂûãÊ†áÁ≠æ
    getTypeLabel(type, category) {
      if (category === 'INCOME') {
        const incomeType = this.INCOME_TYPES[type];
        return incomeType ? incomeType.label || 'Other Income' : 'Other Income';
      } else if (category === 'CREDIT') {
        const creditType = this.CREDIT_TYPES[type];
        return creditType ? creditType.label || 'Tax Refund' : 'Tax Refund';
      } else if (category === 'DEDUCTION') {
        const deductionType = this.DEDUCTION_TYPES[type];
        return deductionType ? deductionType.label || 'Business Expense' : 'Business Expense';
      }
      return type;
    },
    
    // Update task completion status
    updateTaskStatus(index) {
      // Here you would typically send the update to your backend
      console.log(`Task ${this.tasks[index].description} set to ${this.tasks[index].completed}`);
      
      // Save tasks to localStorage for persistence
      localStorage.setItem('taxTasks', JSON.stringify(this.tasks));
    },
    
    // Export report as CSV
    exportReport() {
      const allData = [...this.paymentHistory];
      
      // Sort by date
      allData.sort((a, b) => new Date(a.date) - new Date(b.date));
      
      // Create CSV content
      let csvContent = "data:text/csv;charset=utf-8,";
      csvContent += "Date,Description,Type,Amount\n";
      
      allData.forEach(item => {
        csvContent += `${this.formatDate(item.date)},${item.description},${item.type},${item.amount}\n`;
      });
      
      // Create download link
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", `tax_report_${this.filterStartYear}_${this.filterEndYear}.csv`);
      document.body.appendChild(link);
      
      // Trigger download
      link.click();
      document.body.removeChild(link);
    },
    
    // Apply selected filters with validation
    applyFilters() {
      // È™åËØÅÂπ¥‰ªΩËåÉÂõ¥
      this.validateYearRange();
      
      // Êõ¥Êñ∞ËßÜÂõæÊ®°Âºè
      this.viewMode = this.filterViewMode;
      
      // Ê∏ÖÁ©∫ÂΩìÂâçÊï∞ÊçÆ
      this.taxLiabilities = [];
      this.paymentHistory = [];
      this.outstandingItems = [];
      
      // Process all data with new filters
      this.processFormData();
      this.showFilterOptions = false;
      
      // Âº∫Âà∂Êõ¥Êñ∞ËßÜÂõæ
      this.$forceUpdate();
      
      console.log(`Filters applied. Current view mode: ${this.viewMode}, Tax liabilities: ${this.taxLiabilities.length}, Current tax liabilities: ${this.currentTaxLiabilities.length}`);
    },
    
    // Reset filters to defaults
    resetFilters() {
      this.resetYearDefaults();
      this.filterViewMode = 'yearly';
      this.filterQuarter = 'all';
      this.filterQuarterYear = new Date().getFullYear();
      this.processFormData();
      this.showFilterOptions = false;
    },
    
    // Load initial tasks from localStorage
    loadTasks() {
      try {
        const savedTasks = localStorage.getItem('taxTasks');
        if (savedTasks) {
          this.tasks = JSON.parse(savedTasks);
        }
      } catch (e) {
        console.error("Error loading saved tasks:", e);
      }
    },
    
    totalIncome() {
      return this.incomeData.reduce((sum, item) => sum + item.amount, 0);
    },
    
    totalExpense() {
      return this.expenseData.reduce((sum, item) => sum + item.amount, 0);
    },
    
    netAmount() {
      return this.totalIncome - this.totalExpense;
    },

    goBack() {
      // Return to the previous page
      this.$router.go(-1);
    },

    // Ensure canvas containers are ready for charting
    ensureChartCanvasReady() {
      // Fix income chart container
      const incomeChartElement = document.getElementById('income-chart');
      if (incomeChartElement) {
        // Reset canvas by replacing it with a fresh one
        const parentElement = incomeChartElement.parentElement;
        if (parentElement) {
          // Remove old canvas
          parentElement.removeChild(incomeChartElement);
          
          // Create and append new canvas
          const newCanvas = document.createElement('canvas');
          newCanvas.id = 'income-chart';
          newCanvas.className = 'chart-area';
          parentElement.appendChild(newCanvas);
        }
      }
      
      // Fix expense chart container
      const expenseChartElement = document.getElementById('expense-chart');
      if (expenseChartElement) {
        // Reset canvas by replacing it with a fresh one
        const parentElement = expenseChartElement.parentElement;
        if (parentElement) {
          // Remove old canvas
          parentElement.removeChild(expenseChartElement);
          
          // Create and append new canvas
          const newCanvas = document.createElement('canvas');
          newCanvas.id = 'expense-chart';
          newCanvas.className = 'chart-area';
          parentElement.appendChild(newCanvas);
        }
      }
    },
    
    // Change view mode between yearly and quarterly
    changeViewMode(mode) {
      if (this.viewMode !== mode) {
        console.log(`View mode changing from ${this.viewMode} to ${mode}`);
        this.viewMode = mode;
        
        // Reset charts before re-rendering
        this.destroyCharts();
        
        // ÂÆåÂÖ®ÈáçÁΩÆÊï∞ÊçÆ
        this.taxLiabilities = [];
        this.paymentHistory = [];
        this.outstandingItems = [];
        
        // Process all data again with the new view mode
        this.processFormData();
        
        // Ê∑ªÂä†Â§ö‰∏™Âª∂ËøüÊ£ÄÊü•ÁÇπÔºåÁ°Æ‰øùËßÜÂõæÊ≠£Á°ÆÊõ¥Êñ∞
        setTimeout(() => {
          console.log(`ËßÜÂõæÂàáÊç¢ÂêéÈ¶ñÊ¨°Ê£ÄÊü•: Á®éÂä°Ë¥üÂÄ∫Êï∞Èáè=${this.taxLiabilities.length}, ÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫=${this.currentTaxLiabilities.length}`);
          // Âº∫Âà∂ÈáçÊñ∞ËÆ°ÁÆóÊâÄÊúâËÆ°ÁÆóÂ±ûÊÄß
          this.$forceUpdate();
          
          // ÂÜçÊ¨°Âª∂ËøüÊ£ÄÊü•
          setTimeout(() => {
            console.log(`ËßÜÂõæÂàáÊç¢ÂêéÂÜçÊ¨°Ê£ÄÊü•: Á®éÂä°Ë¥üÂÄ∫Êï∞Èáè=${this.taxLiabilities.length}, ÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫=${this.currentTaxLiabilities.length}`);
            
            // Â¶ÇÊûúÊï∞ÊçÆ‰ªçÁÑ∂ÊúâÈóÆÈ¢òÔºåÈáçÊñ∞ÊâßË°å‰∏ÄÊ¨°Â§ÑÁêÜ
            if (this.currentTaxLiabilities.length === 0 && this.taxLiabilities.length > 0) {
              console.log("Ê£ÄÊµãÂà∞Êï∞ÊçÆÂºÇÂ∏∏ÔºåÈáçÊñ∞ÊâßË°åÊï∞ÊçÆÂ§ÑÁêÜ");
              // ÈÄíÂΩíË∞ÉÁî®Ëá™Ë∫´Ôºå‰ΩÜ‰ΩøÁî®Áõ∏ÂêåÁöÑÊ®°Âºè‰ª•ÈÅøÂÖçÊó†ÈôêÂæ™ÁéØ
              this.processTaxLiabilities();
              this.$forceUpdate();
            }
          }, 200);
        }, 100);
      }
    },
    
    // Destroy existing charts before recreating them
    destroyCharts() {
      if (this.incomeChart) {
        this.incomeChart.destroy();
        this.incomeChart = null;
      }
      
      if (this.expenseChart) {
        this.expenseChart.destroy();
        this.expenseChart = null;
      }
    },
    
    // Reset chart canvases
    resetChartCanvases() {
      // Reset income chart canvas
      const incomeChartElement = document.getElementById('income-chart');
      if (incomeChartElement) {
        incomeChartElement.innerHTML = '';
      }
      
      // Reset expense chart canvas
      const expenseChartElement = document.getElementById('expense-chart');
      if (expenseChartElement) {
        expenseChartElement.innerHTML = '';
      }
    },
    
    // Ê∑ªÂä†‰∏Ä‰∏™ÊñπÊ≥ïÁî®‰∫éÊâãÂä®Âà∑Êñ∞Á®éÂä°Ë¥üÂÄ∫Êï∞ÊçÆ
    refreshTaxLiabilities() {
      console.log("ÊâãÂä®Âà∑Êñ∞Á®éÂä°Ë¥üÂÄ∫Êï∞ÊçÆ");
      // Ê∏ÖÁ©∫Âπ∂ÈáçÊñ∞Â§ÑÁêÜ
      this.taxLiabilities = [];
      this.processTaxLiabilities();
      this.$forceUpdate();
    },
    
    // Export data in selected format
    exportData() {
      if (!this.exportOptions.liabilities && !this.exportOptions.transactions && !this.exportOptions.outstanding) {
        alert('Please select at least one data section to export');
        return;
      }
      
      if (this.exportFormat === 'csv') {
        this.exportAsCSV();
      } else if (this.exportFormat === 'pdf') {
        this.exportAsPDF();
      }
      
      this.showExportOptions = false;
    },
    
    // Export data as CSV
    exportAsCSV() {
      let allData = [];
      
      // Add tax liabilities data
      if (this.exportOptions.liabilities) {
        this.currentTaxLiabilities.forEach(liability => {
          allData.push({
            section: 'Current Tax Liabilities',
            name: liability.name,
            amount: liability.amount,
            date: this.formatDate(liability.dueDate),
            status: liability.statusText,
            type: 'N/A',
            description: liability.name
          });
        });
      }
      
      // Add payment history data
      if (this.exportOptions.transactions) {
        this.paymentHistory.forEach(payment => {
          allData.push({
            section: 'Financial Transactions History',
            name: payment.transactionType,
            amount: payment.amount,
            date: this.formatDate(payment.date),
            status: 'N/A',
            type: payment.type,
            description: payment.description
          });
        });
      }
      
      // Add outstanding items data
      if (this.exportOptions.outstanding) {
        this.outstandingItems.forEach(item => {
          allData.push({
            section: 'Financial Items & Tax Estimates',
            name: item.type,
            amount: item.amount,
            date: 'N/A',
            status: 'N/A',
            type: item.type,
            description: item.description
          });
        });
      }
      
      // Create merged CSV content with all data
      let csvContent = "data:text/csv;charset=utf-8,";
      csvContent += "Section,Name,Amount,Date,Status,Type,Description\n";
      
      allData.forEach(item => {
        const amount = new Intl.NumberFormat('en-US', { 
          style: 'currency', 
          currency: 'USD'
        }).format(item.amount);
        
        csvContent += `${item.section},${item.name},${amount},${item.date},${item.status},${item.type},${item.description}\n`;
      });
      
      // Create download link
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      
      // Set filename based on current filter
      let filename = `tax_report_`;
      if (this.viewMode === 'yearly') {
        filename += `${this.filterStartYear}_${this.filterEndYear}`;
      } else {
        filename += `${this.filterQuarterYear}_Q${this.filterQuarter !== 'all' ? this.filterQuarter : 'all'}`;
      }
      filename += `.csv`;
      
      link.setAttribute("download", filename);
      document.body.appendChild(link);
      
      // Trigger download
      link.click();
      document.body.removeChild(link);
    },
    
    // Export data as PDF
    exportAsPDF() {
      // Dynamically load jsPDF library from CDN
      if (!window.jspdf) {
        try {
          // Show loading message
          alert('Preparing PDF generator. This might take a moment. Click OK and wait for the download to start.');
          
          // First load the main jsPDF library
          const script = document.createElement('script');
          script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js';
          script.async = true;
          
          // Use a Promise to track loading
          const jspdfLoaded = new Promise((resolve, reject) => {
            script.onload = resolve;
            script.onerror = () => reject(new Error('Failed to load jsPDF library'));
          });
          
          document.head.appendChild(script);
          
          // When jsPDF is loaded, then load the autoTable plugin
          jspdfLoaded.then(() => {
            // Ensure jsPDF is available
            if (!window.jspdf) {
              throw new Error('jsPDF failed to initialize properly');
            }
            
            console.log('jsPDF loaded successfully, loading autoTable plugin');
            
            // Now load the autoTable plugin
            const autoTableScript = document.createElement('script');
            autoTableScript.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js';
            autoTableScript.async = true;
            
            // Return a new promise for autoTable loading
            return new Promise((resolve, reject) => {
              autoTableScript.onload = resolve;
              autoTableScript.onerror = () => reject(new Error('Failed to load autoTable plugin'));
              document.head.appendChild(autoTableScript);
            });
          })
          .then(() => {
            // Both libraries should be loaded, give a moment for initialization
            console.log('AutoTable plugin loaded, waiting for initialization');
            return new Promise(resolve => setTimeout(resolve, 1000));
          })
          .then(() => {
            // Verify that jsPDF object exists and has autoTable method attached
            if (!window.jspdf) {
              throw new Error('jsPDF library not found after loading');
            }
            
            // Create a test instance to verify autoTable is attached
            const { jsPDF } = window.jspdf;
            const testDoc = new jsPDF();
            
            if (typeof testDoc.autoTable !== 'function') {
              throw new Error('autoTable plugin not properly initialized');
            }
            
            console.log('All PDF libraries successfully loaded and initialized');
            this.generatePDF();
          })
          .catch(error => {
            console.error('Error loading PDF libraries:', error);
            alert('Failed to load PDF generation libraries: ' + error.message + '\nPlease try using CSV format instead.');
          });
        } catch (error) {
          console.error('Error in PDF export setup:', error);
          alert('Failed to initialize PDF export: ' + error.message + '\nPlease try the CSV option instead.');
        }
      } else {
        // Verify autoTable is available before proceeding
        try {
          const { jsPDF } = window.jspdf;
          const testDoc = new jsPDF();
          
          if (typeof testDoc.autoTable !== 'function') {
            throw new Error('autoTable plugin not properly initialized');
          }
          
          this.generatePDF();
        } catch (error) {
          console.error('Error checking PDF libraries:', error);
          alert('PDF export unavailable: ' + error.message + '\nPlease try using CSV format instead.');
        }
      }
    },
    
    // Generate PDF content using jsPDF
    generatePDF() {
      try {
        // Create new PDF document
        const { jsPDF } = window.jspdf;
        if (!jsPDF) {
          throw new Error('jsPDF constructor not found');
        }
        
        const doc = new jsPDF();
        
        // Verify autoTable is available
        if (typeof doc.autoTable !== 'function') {
          throw new Error('autoTable plugin not properly initialized');
        }
        
        // Add title
        doc.setFontSize(18);
        doc.text('Tax Dashboard Report', 14, 20);
        
        // Add subtitle with filter info
        doc.setFontSize(12);
        let filterText = this.viewMode === 'yearly' 
          ? `Year Range: ${this.filterStartYear} - ${this.filterEndYear}` 
          : `Year: ${this.filterQuarterYear}, Quarter: ${this.filterQuarter !== 'all' ? `Q${this.filterQuarter}` : 'All Quarters'}`;
        doc.text(`Filter: ${filterText}`, 14, 28);
        doc.text(`Generated on: ${new Date().toLocaleDateString()}`, 14, 34);
        
        let yPos = 40;
        
        // Add tax liabilities section
        if (this.exportOptions.liabilities && this.currentTaxLiabilities.length > 0) {
          yPos += 8;
          doc.setFontSize(14);
          doc.text('Current Tax Liabilities', 14, yPos);
          yPos += 8;
          
          // Prepare table data
          const liabilitiesData = this.currentTaxLiabilities.map(liability => [
            liability.name,
            this.formatCurrency(liability.amount),
            this.formatDate(liability.dueDate),
            liability.statusText
          ]);
          
          // Add table
          doc.autoTable({
            startY: yPos,
            head: [['Tax Liability', 'Amount', 'Due Date', 'Status']],
            body: liabilitiesData,
            theme: 'striped',
            headStyles: { fillColor: [31, 58, 147] }
          });
          
          yPos = doc.lastAutoTable.finalY + 10;
          
          // Add summary
          if (this.currentTaxLiabilities.length > 0) {
            doc.text(`Total Tax Obligations: ${this.formatCurrency(this.totalTaxObligations)}`, 14, yPos);
            yPos += 10;
          }
        }
        
        // Check if we need a new page for payment history
        if (yPos > 200 && this.exportOptions.transactions) {
          doc.addPage();
          yPos = 20;
        }
        
        // Add payment history section
        if (this.exportOptions.transactions && this.paymentHistory.length > 0) {
          doc.setFontSize(14);
          doc.text('Financial Transactions History', 14, yPos);
          yPos += 8;
          
          // Prepare table data
          const transactionData = this.paymentHistory.map(payment => [
            this.formatDate(payment.date),
            payment.transactionType,
            payment.description,
            this.formatCurrency(payment.amount)
          ]);
          
          // Add table
          doc.autoTable({
            startY: yPos,
            head: [['Date', 'Type', 'Description', 'Amount']],
            body: transactionData,
            theme: 'striped',
            headStyles: { fillColor: [31, 58, 147] }
          });
          
          yPos = doc.lastAutoTable.finalY + 10;
          
          // Add summary
          if (this.paymentHistory.length > 0) {
            doc.text(`Net Income/Expense: ${this.formatCurrency(this.netTransactionAmount)}`, 14, yPos);
            yPos += 10;
          }
        }
        
        // Check if we need a new page for outstanding items
        if (yPos > 200 && this.exportOptions.outstanding) {
          doc.addPage();
          yPos = 20;
        }
        
        // Add outstanding items section
        if (this.exportOptions.outstanding && this.outstandingItems.length > 0) {
          doc.setFontSize(14);
          doc.text('Financial Items & Tax Estimates', 14, yPos);
          yPos += 8;
          
          // Prepare table data
          const outstandingData = this.outstandingItems.map(item => [
            item.type,
            item.description,
            this.formatCurrency(item.amount)
          ]);
          
          // Add table
          doc.autoTable({
            startY: yPos,
            head: [['Type', 'Description', 'Amount']],
            body: outstandingData,
            theme: 'striped',
            headStyles: { fillColor: [31, 58, 147] }
          });
          
          yPos = doc.lastAutoTable.finalY + 10;
          
          // Add summary
          if (this.outstandingItems.length > 0) {
            doc.text(`Net Financial Position: ${this.formatCurrency(this.netOutstandingAmount)}`, 14, yPos);
          }
        }
        
        // Set filename
        let filename = `tax_report_`;
        if (this.viewMode === 'yearly') {
          filename += `${this.filterStartYear}_${this.filterEndYear}`;
        } else {
          filename += `${this.filterQuarterYear}_Q${this.filterQuarter !== 'all' ? this.filterQuarter : 'all'}`;
        }
        filename += `.pdf`;
        
        // Save the PDF
        doc.save(filename);
      } catch (error) {
        console.error('Error generating PDF:', error);
        alert('Failed to generate PDF. Please try again or use CSV format instead. Error: ' + error.message);
      }
    }
  },
  
  mounted() {
    console.log("Dashboard component loaded");
    
    // Load tasks from localStorage
    this.loadTasks();
    
    // Fetch form data from server
    this.fetchFormData();
    
    // Set up auto-refresh interval (every 5 minutes)
    this.refreshInterval = setInterval(() => {
      console.log("Auto-refreshing form data");
      this.fetchFormData();
    }, 5 * 60 * 1000);
  },
  
  beforeUnmount() {
    // Clear interval when component is unmounted
    if (this.refreshInterval) {
      clearInterval(this.refreshInterval);
    }
    
    // Destroy chart instances
    if (this.incomeChart) {
      this.incomeChart.destroy();
    }
    if (this.expenseChart) {
      this.expenseChart.destroy();
    }
  },
  
  watch: {
    // Watch for changes in filters
    filterYear() {
      console.log(`Year filter changed to: ${this.filterYear}`);
    },
    filterMonth() {
      console.log(`Month filter changed to: ${this.filterMonth}`);
    },
    // Add a new watcher for viewMode
    viewMode(newMode, oldMode) {
      console.log(`View mode changed from ${oldMode} to ${newMode}`);
      // viewMode change is already handled in changeViewMode method
    }
  },
  
  computed: {
    // Âè™Ëé∑ÂèñÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫Ôºå‰∏çÂåÖÊã¨È¢ÑÊµãÊÄßÈ°πÁõÆÂíåË¥üÂÄºÈ°πÁõÆ
    currentTaxLiabilities() {
      console.log(`ËÆ°ÁÆóÂ±ûÊÄßcurrentTaxLiabilitiesË¢´Ë∞ÉÁî®ÔºåÂΩìÂâçtaxLiabilitiesÈïøÂ∫¶: ${this.taxLiabilities.length}`);
      const result = this.taxLiabilities.filter(liability => {
        // Âè™‰øùÁïôÂÆûÈôÖÁöÑÁ®éÂä°Ë¥üÂÄ∫ÔºåÊéíÈô§È¢ÑÊµãÁöÑÊäïËµÑÂõûÊä•„ÄÅÂà©ÊÅØÁ≠â
        const isActualTaxLiability = 
          !liability.name.toLowerCase().includes('projected') &&
          !liability.name.toLowerCase().includes('interest') &&
          !liability.name.toLowerCase().includes('return') &&
          !liability.name.toLowerCase().includes('estimated tax') && // Êñ∞Â¢ûÔºöÊéíÈô§È¢Ñ‰º∞Á®éÊ¨æ
          liability.amount > 0; // ÈáëÈ¢ù‰∏∫Ê≠£ÔºåË°®Á§∫ÈúÄË¶ÅÊîØ‰ªòÁöÑÁ®éÊ¨æ
        
        // Á°Æ‰øùÊòØÊú™Êù•ÊàñÂΩìÂâçÈúÄË¶ÅÊîØ‰ªòÁöÑÈ°πÁõÆ
        const isCurrentOrUpcoming = 
          liability.status === 'upcoming' || 
          liability.status === 'due-soon' ||
          liability.status === 'overdue';
        
        return isActualTaxLiability && isCurrentOrUpcoming;
      });
      
      console.log(`ËøáÊª§ÂêéÁöÑÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫Êï∞Èáè: ${result.length}`);
      return result;
    },
    
    // ËÆ°ÁÆóÂΩìÂâçÁ®éÂä°Ë¥üÂÄ∫ÊÄªÈ¢ù
    totalTaxObligations() {
      return this.currentTaxLiabilities.reduce((sum, liability) => sum + liability.amount, 0);
    },
    
    // ËÆ°ÁÆóÂáÄ‰∫§ÊòìÈáëÈ¢ùÔºàÊâÄÊúâPayment History‰∏≠ÁöÑÊî∂ÂÖ•ÂáèÂéªÊîØÂá∫Ôºâ
    netTransactionAmount() {
      return this.paymentHistory.reduce((sum, payment) => {
        if (payment.type === 'credit') {
          return sum + payment.amount;
        } else {
          return sum - payment.amount;
        }
      }, 0);
    },
    // ËÆ°ÁÆóÂáÄË¥¢Âä°Áä∂ÂÜµÔºàÊâÄÊúâOutstanding Items‰∏≠ÁöÑÊî∂ÂÖ•ÂáèÂéªÊîØÂá∫Ôºâ
    netOutstandingAmount() {
      return this.outstandingItems.reduce((sum, item) => {
        if (item.type === 'Credit') {
          return sum + item.amount;
        } else if (item.type === 'Debit') {
          // Êñ∞Â¢ûÊù°‰ª∂ÔºöÂ¶ÇÊûúËøô‰∏™DebitÈ°πÊòØÈ¢Ñ‰º∞Á®éÔºàÈÄöËøádescriptionÂà§Êñ≠ÔºâÔºåÂàô‰∏çËÆ°ÂÖ•netOutstandingAmountÁöÑËÆ°ÁÆó
          if (item.description && item.description.toLowerCase().includes('estimated tax')) {
            return sum; // ‰øùÊåÅsum‰∏çÂèòÔºåÂç≥‰∏çÂáèÂéªËøô‰∏™È¢Ñ‰º∞Á®éÁöÑÈáëÈ¢ù
          }
          return sum - item.amount; // ÂÖ∂‰ªñÈùûÈ¢Ñ‰º∞ÁöÑDebitÈ°πÊ≠£Â∏∏ÂáèÂéª
        }
        return sum; // ÂØπ‰∫éÂÖ∂‰ªñÁ±ªÂûãÔºàÂ¶ÇÊûúÊúâÁöÑËØùÔºâÔºå‰øùÊåÅsum‰∏çÂèò
      }, 0);
    },
    // ËÆ°ÁÆóÂáÄÁ®éÂä°Áä∂ÂÜµÔºàÊâÄÊúâTax Liabilities‰∏≠ÁöÑÊî∂ÂÖ•ÂáèÂéªÊîØÂá∫Ôºâ
    netTaxAmount() {
      return this.taxLiabilities.reduce((sum, liability) => {
        if (liability.amount < 0) {
          return sum + liability.amount;
        } else {
          return sum - liability.amount;
        }
      }, 0);
    }
  }
}
</script>

<style scoped>
/* ‰∏ªÂÆπÂô®Ê†∑Âºè */
.dashboard-container {
  padding: 18px;
  display: flex;
  justify-content: center;
  align-items: flex-start;
  min-height: 100vh;
  background-color: #E5E5E5;
}

/* ‰∏ªÂç°ÁâáÊ†∑Âºè */
.main-card {
  position: relative;
  background-color: #E1E1E1;
  border-radius: 10px;
  padding: 24px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  width: 100%;
  max-width: 1320px;
  margin: 0 auto;
}

.dashboard-title {
  text-align: center;
  margin-top: 0;
  margin-bottom: 24px;
  font-size: 24px;
  color: #333;
  font-weight: bold;
}

/* ÁªÑ‰ª∂Ë°åÂ∏ÉÂ±Ä */
.components-row {
  display: flex;
  gap: 12px;
  margin-bottom: 12px;
}

.charts-row {
  margin-top: 12px;
}

/* ÂÜÖÈÉ®Âç°ÁâáÊ†∑Âºè */
.inner-card {
  flex: 1;
  background-color: #F5F5F5;
  border-radius: 7px;
  padding: 10px;
  height: 264px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.inner-card h3 {
  margin-top: 0;
  margin-bottom: 7px;
  font-size: 16px;
  color: #333;
  font-weight: bold;
}

/* ÂèØÊªöÂä®ÂÜÖÂÆπÂå∫Âüü */
.scrollable-content {
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
  margin-bottom: 5px;
  border-bottom: 1px solid #eee;
}

/* Âõ∫ÂÆöÊëòË¶ÅÂå∫Âüü */
.fixed-summary {
  padding: 8px 0;
  background-color: #f5f5f5;
  border-top: 1px solid #eee;
  font-weight: bold;
}

.fixed-summary .summary-row {
  display: flex;
  justify-content: space-between;
  padding: 5px 15px;
  background-color: #f9f9f9;
}

.fixed-summary .summary-item {
  padding: 5px 0;
}

/* ‰ªªÂä°ÈÉ®ÂàÜ */
.tasks-section {
  overflow: hidden;
}

.liabilities-list {
  display: flex;
  flex-direction: column;
  gap: 7px;
}

.liability-item {
  display: flex;
  flex-direction: column;
  background-color: #f9f9f9;
  border-radius: 6px;
  padding: 10px;
  box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.liability-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
}

.liability-name {
  font-weight: 600;
}

.liability-amount {
  font-weight: 600;
  color: #d32f2f;
}

.liability-due-date {
  font-size: 0.85rem;
  color: #666;
  margin-bottom: 5px;
}

.liability-status {
  font-size: 0.8rem;
  font-weight: 600;
  padding: 2px 8px;
  border-radius: 12px;
  display: inline-block;
  width: fit-content;
}

.liability-status.overdue {
  background-color: #ffebee;
  color: #c62828;
}

.liability-status.due-soon {
  background-color: #fff8e1;
  color: #ff8f00;
}

.liability-status.upcoming {
  background-color: #e8f5e9;
  color: #2e7d32;
}

/* Ë¥¢Âä°Ë°®Ê†ºÈÉ®ÂàÜ */
table {
  width: 100%;
  border-collapse: collapse;
  background: white;
  border-radius: 5px;
  overflow: hidden;
  font-size: 13px;
}

th, td {
  padding: 6px;
  text-align: left;
  border-bottom: 1px solid #eee;
}

th {
  background-color: #f9f9f9;
  font-weight: 600;
  color: #333;
  position: sticky;
  top: 0;
  z-index: 2;
}

.amount {
  text-align: right;
  font-weight: 600;
}

.positive {
  color: #2e7d32;
}

.negative {
  color: #d32f2f;
}

.no-data {
  text-align: center;
  padding: 8px;
  color: #888;
  font-style: italic;
}

.summary-label {
  font-weight: bold;
  padding-right: 10px;
}

.summary-amount {
  font-weight: 600;
}

/* Êìç‰ΩúÊéßÂà∂ÈÉ®ÂàÜ */
.action-controls {
  display: flex;
  flex-direction: column;
  justify-content: space-between;
}

.action-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
  flex: 1;
  justify-content: flex-start;
  margin-bottom: 10px;
}

button {
  padding: 10px;
  border: none;
  border-radius: 5px;
  font-weight: 600;
  font-size: 13px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-export, .btn-filter, .btn-apply {
  background-color: #1F3A93;
  color: white;
  padding: 8px 12px;
  font-size: 12px;
  font-weight: 600;
  border-radius: 4px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
  text-align: center;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
}

.btn-export:hover, .btn-filter:hover, .btn-apply:hover {
  background-color: #142c70;
  box-shadow: 0 2px 5px rgba(0,0,0,0.3);
}

.btn-reset {
  background-color: #757575;
  color: white;
}

.btn-reset:hover {
  background-color: #616161;
}

/* ÂõæË°®Ê†∑Âºè */
.chart {
  height: 168px;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: #FFF;
  border-radius: 5px;
  overflow: hidden;
  position: relative;
}

.chart-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #888;
  font-style: italic;
}

.placeholder-text {
  text-align: center;
  padding: 10px;
}

.chart-area {
  width: 100%;
  height: 100%;
}

/* ËøáÊª§Âô®Èù¢Êùø */
.filter-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.filter-backdrop {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.5);
  backdrop-filter: blur(2px);
}

.filter-modal {
  position: relative;
  background-color: #F5F5F5;
  padding: 24px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
  z-index: 1001;
}

.close-button {
  position: absolute;
  right: 10px;
  top: 10px;
  background: none;
  border: none;
  font-size: 24px;
  font-weight: bold;
  color: #555;
  cursor: pointer;
  padding: 0;
  width: 30px;
  height: 30px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
  transition: background-color 0.2s;
}

.close-button:hover {
  background-color: rgba(0, 0, 0, 0.1);
}

.filter-modal h3 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 16px;
  color: #333;
  font-weight: bold;
}

.filter-controls {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.filter-section {
  display: flex;
  flex-direction: column;
  gap: 16px;
  width: 100%;
}

.filter-row {
  display: flex;
  gap: 12px;
  width: 100%;
}

.filter-group {
  display: flex;
  flex-direction: column;
  gap: 5px;
}

.half-width {
  flex: 1;
  min-width: 120px;
}

.full-width {
  width: 100%;
}

.filter-group label {
  font-size: 13px;
  color: #555;
  font-weight: 500;
}

.select-control {
  padding: 8px;
  border: 1px solid #ddd;
  border-radius: 5px;
  background-color: white;
  font-size: 13px;
  width: 100%;
}

.filter-actions {
  display: flex;
  gap: 12px;
  margin-top: 8px;
  justify-content: flex-end;
  width: 100%;
}

/* Âä†ËΩΩÊåáÁ§∫Âô®ÂíåÈîôËØØÊ∂àÊÅØÊ†∑Âºè */
.loading-indicator {
  background-color: #e3f2fd;
  color: #0d47a1;
  padding: 10px;
  border-radius: 6px;
  text-align: center;
  margin-bottom: 8px;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.error-message {
  background-color: #ffebee;
  color: #c62828;
  padding: 10px;
  border-radius: 6px;
  text-align: center;
  margin-bottom: 8px;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.btn-test-data {
  background-color: #1F3A93;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 6px 12px;
  cursor: pointer;
  font-weight: 600;
  transition: background-color 0.3s;
}

.btn-test-data:hover {
  background-color: #142c70;
}

.test-mode-badge {
  background-color: #ff9800;
  color: white;
  padding: 8px;
  border-radius: 4px;
  text-align: center;
  margin-bottom: 8px;
  font-weight: bold;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

/* ÂìçÂ∫îÂºèÂ∏ÉÂ±Ä */
@media (max-width: 1024px) {
  .components-row {
    flex-wrap: wrap;
  }
  
  .inner-card {
    flex: 0 0 48%;
    margin-bottom: 10px;
  }
}

@media (max-width: 768px) {
  .inner-card {
    flex: 0 0 100%;
  }
}

/* Êî∂ÂÖ•ÊîØÂá∫Ë°®Ê†ºÂç°Áâá‰∏ìÁî®Ê†∑Âºè */
.income-table, .expense-table {
  height: 264px;
}

/* ÂõæË°®Âç°Áâá‰∏ìÁî®Ê†∑Âºè */
.income-chart-card, .expense-chart-card {
  height: 480px;
}

/* Â¢ûÂä†ÂõæË°®Âå∫ÂüüÈ´òÂ∫¶ */
.income-chart-card .chart, .expense-chart-card .chart {
  height: 480px;
}

.action-icon {
  font-size: 14px;
}

.back-arrow {
  position: absolute;
  top: 15px;
  left: 15px;
  font-size: 16px;
  color: #333;
  cursor: pointer;
  z-index: 10;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 4px;
  background-color: rgba(255, 255, 255, 0.3);
  border-radius: 20px;
  padding: 5px 12px;
  transition: background-color 0.2s, transform 0.2s;
}

.back-arrow:hover {
  background-color: rgba(0, 0, 0, 0.1);
  transform: scale(1.05);
}

.arrow-icon {
  font-size: 18px;
  font-weight: bold;
}

.back-text {
  font-weight: 500;
}

/* Êñ∞Ê†∑Âºè */
.transaction-type {
  font-size: 0.85rem;
  font-weight: 600;
  padding: 2px 6px;
  border-radius: 4px;
  text-align: center;
}

.transaction-type.credit {
  background-color: rgba(46, 125, 50, 0.1);
  color: #2e7d32;
}

.transaction-type.debit {
  background-color: rgba(211, 47, 47, 0.1);
  color: #d32f2f;
}

.summary-row {
  font-weight: bold;
  border-top: 2px solid #ddd;
}

.summary-label {
  text-align: right;
  padding-right: 10px;
}

.info-tooltip {
  display: inline-block;
  position: relative;
  margin-left: 8px;
}

.help-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background-color: #1F3A93;
  color: white;
  font-size: 12px;
  font-weight: bold;
  cursor: help;
}

.tooltip-content {
  display: none;
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  background-color: white;
  border: 1px solid #ddd;
  border-radius: 4px;
  padding: 10px;
  width: 250px;
  z-index: 100;
  box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  font-size: 12px;
}

.tooltip-content p {
  margin: 5px 0;
}

.info-tooltip:hover .tooltip-content {
  display: block;
}

.summary-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 5px 0;
}

.summary-inner {
  display: flex;
  align-items: center;
}

.summary-label {
  font-weight: bold;
  margin-right: 10px;
}

.summary-amount {
  font-weight: 600;
}

/* View toggle buttons */
.view-toggle {
  display: flex;
  justify-content: space-between;
  margin-top: auto;
  width: 100%;
}

.view-btn {
  flex: 1;
  padding: 8px 0;
  background-color: #f1f1f1;
  border: 1px solid #ddd;
  color: #333;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
  text-align: center;
  min-width: 0;
}

.view-btn:first-child {
  border-top-left-radius: 5px;
  border-bottom-left-radius: 5px;
  border-right: none;
}

.view-btn:last-child {
  border-top-right-radius: 5px;
  border-bottom-right-radius: 5px;
  border-left: none;
}

.view-btn.active {
  background-color: #1F3A93;
  color: white;
  border-color: #1F3A93;
}

.view-btn:hover:not(.active) {
  background-color: #e1e1e1;
}

/* Enhanced chart styles */
.charts-row {
  margin-top: 1.5rem;
}

.chart {
  width: 100%;
  height: 100%;
  position: relative;
}

.chart-area {
  width: 100%;
  height: 100%;
}

.chart-placeholder {
  width: 100%;
  height: 100%;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: #f9f9f9;
  border-radius: 8px;
}

.placeholder-text {
  color: #666;
  font-style: italic;
  text-align: center;
  padding: 2rem;
}

/* Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØÊ†∑Âºè */
.debug-info {
  margin: 10px 0;
  padding: 10px;
  background-color: #fff3e0;
  border-radius: 4px;
  font-size: 12px;
  color: #e65100;
}

.btn-refresh {
  background-color: #e65100;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 5px 10px;
  font-size: 12px;
  margin-top: 5px;
  cursor: pointer;
}

.btn-refresh:hover {
  background-color: #bf360c;
}

/* ÂØºÂá∫ÈÄâÈ°πÊ†∑Âºè */
.export-modal {
  position: relative;
  background-color: #F5F5F5;
  padding: 24px;
  border-radius: 10px;
  width: 90%;
  max-width: 400px;
  box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
  z-index: 1001;
}

.export-controls {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.export-format-toggle {
  display: flex;
  gap: 10px;
  margin-top: 8px;
}

.toggle-btn {
  flex: 1;
  padding: 8px 15px;
  background-color: #f1f1f1;
  border: 1px solid #ddd;
  color: #333;
  font-weight: 600;
  cursor: pointer;
  border-radius: 5px;
  transition: all 0.2s;
}

.toggle-btn.active {
  background-color: #1F3A93;
  color: white;
  border-color: #1F3A93;
}

.toggle-btn:hover:not(.active) {
  background-color: #e1e1e1;
}

.export-options {
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-top: 8px;
}

.export-option {
  display: flex;
  align-items: center;
  gap: 8px;
}

.export-option input[type="checkbox"] {
  width: 18px;
  height: 18px;
  accent-color: #1F3A93;
}

.export-actions {
  display: flex;
  gap: 12px;
  margin-top: 8px;
  justify-content: flex-end;
}

.btn-export-now {
  background-color: #1F3A93;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-export-now:hover {
  background-color: #142c70;
}

.btn-cancel {
  background-color: #757575;
  color: white;
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-cancel:hover {
  background-color: #616161;
}

.filter-label {
  font-weight: 600;
  color: #333;
  margin-bottom: 8px;
  font-size: 14px;
}

.filter-toggle {
  display: flex;
  gap: 10px;
  margin-top: 8px;
}
</style>